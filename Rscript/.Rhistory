data_fs<-as.data.table(data_fs)
data_fs<-melt.data.table(data_fs,1:3)
names(data_fs)<-c("종목코드","종류","계정","일자","값")
data_fs$값<-data_fs$값*100000000
data_fs<-data_fs[!is.na(data_fs$값),]
return(data_fs)
}
getCurrentPrice<-function(code){
url = paste0('https://comp.fnguide.com/SVO2/ASP/SVD_main.asp?pGB=1&gicode=A',code)
data = GET(url)
price = read_html(data) %>%
html_node(xpath = '//*[@id="svdMainChartTxt11"]') %>%
html_text() %>%
parse_number()
return(price)
}
#현재 주식 수
getCurrentStockNumbers<-function(code){
url = paste0('https://comp.fnguide.com/SVO2/ASP/SVD_main.asp?pGB=1&gicode=A',code)
data = GET(url)
share = read_html(data) %>%
html_node(xpath = '//*[@id="svdMainGrid1"]/table/tbody/tr[7]/td[1]') %>%
html_text() %>%
strsplit('/') %>%
unlist() %>%
parse_number()
return(share)
}
#현재 보통주 수
getCurrentOrdinaryStockNumbers<-function(code){
return(getCurrentStockNumbers(code)[1])
}
#현재 우선주 수
getCurrentPreferredStockNumbers<-function(code){
return(getCurrentStockNumbers(code)[2])
}
getPriceList<-function(businessDay, codeList){
result<-c()
for(code in codeList){
result[code]=getCurrentPrice(code)
}
return(result)
}
getStockNumberList<-function(businessDay, codeList){
result<-data.frame(ordinary=double(),preferred=double())
for(code in codeList){
result[code,] <- getCurrentStockNumbers(code)
}
return(result)
}
cleanDataAndExtractEntitiesFromFS<-function(corpData,yearData,quarterData,isNew){
result<-NULL
tryCatch(
{
businessDate<-as.Date(corpData[[1]],format='%Y-%m-%d')
code<-corpData[[2]]
yData<-yearData[종목코드==code]
qData<-quarterData[종목코드==code]
lastYearDate<-businessDate %m+% months(-12)
yData<-yData[등록일자>=lastYearDate]
qData<-qData[등록일자>=lastYearDate]
if(!isNew){
yData<-yData[등록일자<=businessDate]
qData<-qData[등록일자<=businessDate]
}
yDate<-as.character(yData$일자)
qDate<-as.character(qData$일자)
qRank<-frank(-as.double(qDate),ties.method="dense")
yRank<-frank(-as.double(yDate),ties.method="dense")
if(length(yRank) == 0 & length(unique(qRank)) < 4 ){return(result)}
curQRange<-diff(range(as.double(qDate)[qRank<5]))
if(length(unique(qDate))>=4 & curQRange<=1){
data<-qData[qRank<=4]
} else{ data<-yData[yRank==1] }
result <- extractFSEntities(corpData, data)
},
error=function(e) print(paste0("Fail to Read: ",code," Date:",businessDate))
)
return(result)
}
sumQuarterData<-function(data){
fs<-data[data$종류=='재무상태표']
data<-data[data$종류!='재무상태표']
fs<-fs[fs$일자==max(fs$일자)]
fs<-fs[,-c('일자','등록일자')]
if(length(unique(data$일자))>1) data<-data[,.(값=sum(값)),by=c('종목코드','종류','계정')] else{
data<-data[,-c('일자','등록일자')]
}
names(fs)<-names(data)
data<-rbind(data,fs)
return(data)
}
extractFSEntities<-function(corpData,data){
marketPrice<-corpData$시가총액
code<-corpData$종목코드
data<-data[data$종목코드==code]
data<-unique(data,by=c("종목코드","종류","계정","일자"),fromLast=T)
if(length(unique(data$일자))==4){
data<-sumQuarterData(data)
}
#  data[,일자:=corpData[[1]]]
#  data<-subset(data,select=c(5,1,2,3,4))
value_type <- c('지배주주순이익','자본','자본금','영업활동으로인한현금흐름',
'재무활동으로인한현금흐름','투자활동으로인한현금흐름','매출액','매출총이익','영업이익',
'유동자산','부채','유상증자','자산','유동부채','당기순이익')
tmp<-data[data[,계정 %in% value_type]]$값
names(tmp)<-data[data[,계정 %in% value_type]]$계정
corpData[,':='(자산=tmp['자산'],유동자산=tmp['유동자산'],부채=tmp['부채'],유동부채=tmp['유동부채'],
자본=tmp['자본'],자본금=tmp['자본금'],매출액=tmp['매출액'],매출총이익=tmp['매출총이익'],
영업이익=tmp['영업이익'],지배주주순이익=tmp['지배주주순이익'],당기순이익=tmp['당기순이익'],
영업활동으로인한현금흐름=tmp['영업활동으로인한현금흐름'],
재무활동으로인한현금흐름=tmp['재무활동으로인한현금흐름'],
투자활동으로인한현금흐름=tmp['투자활동으로인한현금흐름'],
유상증자=tmp['유상증자'])]
return(corpData)
}
addMomentum<-function(businessDay, codeList){
result<-NULL
for(code in codeList){
tryCatch(
{
priceList<-adjustedPriceFromNaver('day',365,code)
Return<-Return.calculate(priceList)
Return<-Return[!is.na(Return)]
volatility<-sd(Return)*sqrt(length(Return))
monthPrice<-adjustedPriceFromNaver('month',14,code)[,1]
latestValue<-monthPrice[13]
monthlyMomentum<-latestValue/monthPrice[-12:-13]-1
avgMomentum<-(mean(monthlyMomentum))/volatility
result2<-rbind(result,unlist(c('종목코드'=code,Momentum=avgMomentum)))
Sys.sleep(0.3)
},
error=function(e) print(paste0("Fail to Read: ",code))
)
}
return(result)
}
winsorizing<-function(val){
newval<-ifelse(percent_rank(val)>0.99,
quantile(val,0.99,na.rm=TRUE),val)
return(newval)
}
down_monitoring<-KRXMonitoringStat()
down_monitoring
# 개별종목 지표 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
# 산업별 현황 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
gen_otp_data = list(
mktId = 'ALL',
trdDd = businessDay,
money = '1',
csvxls_isNo = 'false',
name = 'fileDown',
url='dbms/MDC/STAT/standard/MDCSTAT03901'
)
businessDay<-'20210817'
# 산업별 현황 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
gen_otp_data = list(
mktId = 'ALL',
trdDd = businessDay,
money = '1',
csvxls_isNo = 'false',
name = 'fileDown',
url='dbms/MDC/STAT/standard/MDCSTAT03901'
)
otp = POST(gen_otp_url, query = gen_otp_data) %>%
read_html() %>%
html_text()
otp
# 산업별 현황 데이터 다운로드
down_url = 'http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd'
down_sector = POST(down_url, query = list(code = otp)) %>%
read_html(.,encoding='cp949') %>%
html_text() %>%
read_csv()
POST(down_url, query = list(code = otp))
down_sector = POST(down_url, query = list(code = otp)) %>%
read_html(.,encoding='cp949')
down_sector
KRXMonitoringStat()
a<-KRXMonitoringStat()
a
down_ind<-KRXIndividualStat(businessDay)
down_ind
down_sector_KOSPI<-KRXIndStat(businessDay,'STK')
down_sector_KOSDAQ<-KRXIndStat(businessDay,'KSQ')
down_sector<-rbind(down_sector_KOSPI,down_sector_KOSDAQ)
down_sector
down_monitoring<-KRXMonitoringStat()
down_monitoring$관리종목<-str_replace_all(down_monitoring$관리종목,'O','관리종목')
down_monitoring$관리종목<-str_replace_all(down_monitoring$관리종목,'X','-')
down_monitoring<-down_monitoring[,c(1,2,5)]
down_ind<-KRXIndividualStat(businessDay)
down_ind
#데이터 정리(개별종목, 산업현황 데이터 병합)
setdiff(down_sector[,'종목명'],down_ind[,'종목명']) #겹치지 않은 종목 ->제외(일반적이지 않은 종목들)
KOR_ticker = merge(down_sector, down_ind,
by = intersect(names(down_sector),names(down_ind)),
all = FALSE
)
KOR_ticker
down_sector
down_ind
merge(down_sector, down_ind,
by = intersect(names(down_sector),names(down_ind)),
all = FALSE
)
names(down_sector)
names(down_ind)
?setdiff
?html_table
library(rvest)
?html_table
html_table
a<-c()
a<-c(a,1)
a
a<-c(a,2)
a
a<-c(a,3)
a<-c(a,3)
a
length(a)
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
#setwd("C:/Users/vicen/Documents/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-5
coinNumLimit<-100
bandLimit<-0.5
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1. 전체 시장의 모멘텀 계산(3개월로 계산)
#전체 시장에서 상승하는 모멘텀의 개수비율로 코인과 현금의 비중 조절
#시총 상위 100개의 코인으로 모멘텀 계산산
#현금비중=100-margetStrength
momentumList<-getUpbitCoinMomentum("days","",c(100),c(1), coinList$symbol)
marketStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
#모멘텀 방식: 0 ~ 50%, 인덱스: 나머지
#지금 1달 간의 모멘텀 계산
#상위 5개의 코인 매입
momentumList<-getUpbitCoinMomentum("days","",c(10,20,30),c(0.5,0.3,0.2),getUpbitCoinList()$market)
momentumStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
momentumRatioLimit<-marketStrength*momentumStrength*0.5
momentumCoin<-getMomentumBalance(coinList,num,momentumRatioLimit,"EQUAL",momentumList)
momentumCoin
#인덱스
#5개의 코인 구입
#비율:
indexLimitRatio <- marketStrength-momentumRatioLimit
indexCoin<-getIndexBalance(coinList[1:num,],indexLimitRatio,"MARKET")
coinMomentumUnionTable<-rbind(indexCoin,momentumCoin)
coinMomentumUnionTable<-coinMomentumUnionTable[,.(ratio=sum(ratio)),by=c("symbol","market","market_cap")]
#totalBalance<-sum(currentBalance$balance)
balanceCombinedTable<-merge(coinMomentumUnionTable,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-ratio)]
balanceCombinedTable[,outsideofBand:=diffRatio>ratio*bandLimit]
balanceCombinedTable
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
#setwd("C:/Users/vicen/Documents/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-5
coinNumLimit<-100
bandLimit<-0.5
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1. 전체 시장의 모멘텀 계산(3개월로 계산)
#전체 시장에서 상승하는 모멘텀의 개수비율로 코인과 현금의 비중 조절
#시총 상위 100개의 코인으로 모멘텀 계산산
#현금비중=100-margetStrength
momentumList<-getUpbitCoinMomentum("days","",c(100),c(1), coinList$symbol)
marketStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
#모멘텀 방식: 0 ~ 50%, 인덱스: 나머지
#지금 1달 간의 모멘텀 계산
#상위 5개의 코인 매입
momentumList<-getUpbitCoinMomentum("days","",c(10,20,30),c(0.5,0.3,0.2),getUpbitCoinList()$market)
momentumStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
momentumRatioLimit<-marketStrength*momentumStrength*0.5
momentumCoin<-getMomentumBalance(coinList,num,momentumRatioLimit,"EQUAL",momentumList)
#인덱스
#5개의 코인 구입
#비율:
indexLimitRatio <- marketStrength-momentumRatioLimit
indexCoin<-getIndexBalance(coinList[1:num,],indexLimitRatio,"MARKET")
coinMomentumUnionTable<-rbind(indexCoin,momentumCoin)
coinMomentumUnionTable<-coinMomentumUnionTable[,.(ratio=sum(ratio)),by=c("symbol","market","market_cap")]
#totalBalance<-sum(currentBalance$balance)
balanceCombinedTable<-merge(coinMomentumUnionTable,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-ratio)]
balanceCombinedTable[,outsideofBand:=diffRatio>ratio*bandLimit]
if(sum(balanceCombinedTable$outsideofBand)){
orderTable<-createOrderTable(balanceCombinedTable)
rebalanceTable(orderTable)
} else{
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
log_print("Every coins are in the band. Buy Nothing")
log_close()
}
orderCoin<-function(order){
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x,runif(1,1000,33553)))
url<-"https://api.upbit.com/v1/orders"
failOrder<-c()
for(i in 1:NROW(order)){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",tokenList[i])),body=as.list(order[i,]),encode='json')
log_print(query[i])
log_print(res$status_code)
log_print(rawToChar(res$content))
if(res$status_code!="201") failOrder<-c(failOrder,i)
Sys.sleep(0.3)
}
if(length(failOrder)>0){
Sys.sleep(10)
for(i in failOrder){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",tokenList[i])),body=as.list(order[i,]),encode='json')
log_print(query[i])
log_print(res$status_code)
log_print(rawToChar(res$content))
Sys.sleep(0.3)
}
}
}
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
#setwd("C:/Users/vicen/Documents/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-5
coinNumLimit<-100
bandLimit<-0.5
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1. 전체 시장의 모멘텀 계산(3개월로 계산)
#전체 시장에서 상승하는 모멘텀의 개수비율로 코인과 현금의 비중 조절
#시총 상위 100개의 코인으로 모멘텀 계산산
#현금비중=100-margetStrength
momentumList<-getUpbitCoinMomentum("days","",c(100),c(1), coinList$symbol)
marketStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
#모멘텀 방식: 0 ~ 50%, 인덱스: 나머지
#지금 1달 간의 모멘텀 계산
#상위 5개의 코인 매입
momentumList<-getUpbitCoinMomentum("days","",c(10,20,30),c(0.5,0.3,0.2),getUpbitCoinList()$market)
momentumStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
momentumRatioLimit<-marketStrength*momentumStrength*0.5
momentumCoin<-getMomentumBalance(coinList,num,momentumRatioLimit,"EQUAL",momentumList)
#인덱스
#5개의 코인 구입
#비율:
indexLimitRatio <- marketStrength-momentumRatioLimit
indexCoin<-getIndexBalance(coinList[1:num,],indexLimitRatio,"MARKET")
coinMomentumUnionTable<-rbind(indexCoin,momentumCoin)
coinMomentumUnionTable<-coinMomentumUnionTable[,.(ratio=sum(ratio)),by=c("symbol","market","market_cap")]
#totalBalance<-sum(currentBalance$balance)
balanceCombinedTable<-merge(coinMomentumUnionTable,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-ratio)]
balanceCombinedTable[,outsideofBand:=diffRatio>ratio*bandLimit]
if(sum(balanceCombinedTable$outsideofBand)){
orderTable<-createOrderTable(balanceCombinedTable)
rebalanceTable(orderTable)
} else{
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
log_print("Every coins are in the band. Buy Nothing")
log_close()
}
balanceCombinedTable
marketStrength
momentumStrength
momentumCoin
momentumRatioLimit
momentumList
momentumList[momentum<=100]
momentumCoin
balanceCombinedTable
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
#setwd("C:/Users/vicen/Documents/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-5
coinNumLimit<-100
bandLimit<-0.5
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1. 전체 시장의 모멘텀 계산(3개월로 계산)
#전체 시장에서 상승하는 모멘텀의 개수비율로 코인과 현금의 비중 조절
#시총 상위 100개의 코인으로 모멘텀 계산산
#현금비중=100-margetStrength
momentumList<-getUpbitCoinMomentum("days","",c(100),c(1), coinList$symbol)
marketStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
#모멘텀 방식: 0 ~ 50%, 인덱스: 나머지
#지금 1달 간의 모멘텀 계산
#상위 5개의 코인 매입
momentumList<-getUpbitCoinMomentum("days","",c(10,20,30),c(0.5,0.3,0.2),getUpbitCoinList()$market)
momentumStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
momentumRatioLimit<-marketStrength*momentumStrength*0.5
momentumCoin<-getMomentumBalance(coinList,num,momentumRatioLimit,"EQUAL",momentumList)
#인덱스
#5개의 코인 구입
#비율:
indexLimitRatio <- marketStrength-momentumRatioLimit
indexCoin<-getIndexBalance(coinList[1:num,],indexLimitRatio,"MARKET")
coinMomentumUnionTable<-rbind(indexCoin,momentumCoin)
coinMomentumUnionTable<-coinMomentumUnionTable[,.(ratio=sum(ratio)),by=c("symbol","market","market_cap")]
#totalBalance<-sum(currentBalance$balance)
balanceCombinedTable<-merge(coinMomentumUnionTable,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-ratio)]
balanceCombinedTable[,outsideofBand:=diffRatio>ratio*bandLimit]
if(sum(balanceCombinedTable$outsideofBand)){
orderTable<-createOrderTable(balanceCombinedTable)
rebalanceTable(orderTable)
} else{
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
log_print("Every coins are in the band. Buy Nothing")
log_close()
}
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
#setwd("C:/Users/vicen/Documents/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-5
coinNumLimit<-100
bandLimit<-0.5
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1. 전체 시장의 모멘텀 계산(3개월로 계산)
#전체 시장에서 상승하는 모멘텀의 개수비율로 코인과 현금의 비중 조절
#시총 상위 100개의 코인으로 모멘텀 계산산
#현금비중=100-margetStrength
momentumList<-getUpbitCoinMomentum("days","",c(100),c(1), coinList$symbol)
marketStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
#모멘텀 방식: 0 ~ 50%, 인덱스: 나머지
#지금 1달 간의 모멘텀 계산
#상위 5개의 코인 매입
momentumList<-getUpbitCoinMomentum("days","",c(10,20,30),c(0.5,0.3,0.2),getUpbitCoinList()$market)
momentumStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
momentumRatioLimit<-marketStrength*momentumStrength*0.5
momentumCoin<-getMomentumBalance(coinList,num,momentumRatioLimit,"EQUAL",momentumList)
#인덱스
#5개의 코인 구입
#비율:
indexLimitRatio <- marketStrength-momentumRatioLimit
indexCoin<-getIndexBalance(coinList[1:num,],indexLimitRatio,"MARKET")
coinMomentumUnionTable<-rbind(indexCoin,momentumCoin)
coinMomentumUnionTable<-coinMomentumUnionTable[,.(ratio=sum(ratio)),by=c("symbol","market","market_cap")]
#totalBalance<-sum(currentBalance$balance)
balanceCombinedTable<-merge(coinMomentumUnionTable,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-ratio)]
balanceCombinedTable[,outsideofBand:=diffRatio>ratio*bandLimit]
if(sum(balanceCombinedTable$outsideofBand)){
orderTable<-createOrderTable(balanceCombinedTable)
rebalanceTable(orderTable)
} else{
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
log_print("Every coins are in the band. Buy Nothing")
log_close()
}
balanceCombinedTable
