<<<<<<< HEAD
(sum(b$market_cap/coinTable$market_cap)/10)*coinTable$market_cap/ratio
code<-'003960'
url = paste0(
'https://comp.fnguide.com/SVO2/ASP/'
,'SVD_Finance.asp?pGB=1&gicode=A',
code)
# 이 후 과정은 위와 동일함
# 데이터 다운로드 후 테이블 추출
data = GET(url) %>%
read_html() %>%
html_table()
GET(url)
down_sector_KOSPI<-KRXIndStat(businessDay,'STK')
down_sector_KOSDAQ<-KRXIndStat(businessDay,'KSQ')
pkg = c('magrittr', 'quantmod', 'rvest', 'httr', 'jsonlite',
'readr', 'readxl', 'stringr', 'lubridate', 'dplyr',
'tidyr', 'ggplot2', 'corrplot', 'dygraphs',
'highcharter', 'plotly', 'PerformanceAnalytics',
'nloptr', 'quadprog', 'RiskPortfolios', 'cccp',
'timetk', 'broom', 'stargazer','data.table', 'lubridate')
new.pkg = pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg)) {
install.packages(new.pkg, dependencies = TRUE)}
sapply(pkg,library,character.only=T)
# 최근 영업일 구하기
recentBizDay <- function(){
url = 'https://finance.naver.com/sise/sise_index.nhn?code=KOSPI'
biz_day = GET(url) %>%
read_html(encoding = 'EUC-KR') %>%
html_nodes(xpath =
'//*[@id="time"]') %>%
html_text() %>%
str_match(('[0-9]+.[0-9]+.[0-9]+') ) %>%
str_replace_all('\\.', '')
}
KRXIndStat <- function(businessDay,type){
# 산업별 현황 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
gen_otp_data = list(
mktId = type,
trdDd = businessDay,
money = '1',
csvxls_isNo = 'false',
name = 'fileDown',
url='dbms/MDC/STAT/standard/MDCSTAT03901'
)
otp = POST(gen_otp_url, query = gen_otp_data) %>%
read_html() %>%
html_text()
# 산업별 현황 데이터 다운로드
down_url = 'http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd'
down_sector = POST(down_url, query = list(code = otp)) %>%
read_html(.,encoding='cp949') %>%
html_text() %>%
read_csv()
}
KRXIndividualStat<-function(businessDay){
# 개별종목 지표 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
gen_otp_data = list(
searchType = '1',
mktId = 'ALL',
csvxls_isNo = "false",
name = 'fileDown',
url = 'dbms/MDC/STAT/standard/MDCSTAT03501',
trdDd = businessDay # 최근영업일로 변경
)
otp = POST(gen_otp_url, query = gen_otp_data) %>%
read_html() %>%
html_text()
# 개별종목 지표 데이터 다운로드
down_url = 'http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd'
down_ind = POST(down_url, query = list(code = otp)) %>%
read_html(.,encoding='cp949') %>%
html_text() %>%
read_csv()
}
KRXMonitoringStat<-function(){
# 개별종목 지표 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
gen_otp_data = list(
mktId = 'ALL',
csvxls_isNo = "false",
name = 'fileDown',
url = 'dbms/MDC/STAT/standard/MDCSTAT02001'
)
otp = POST(gen_otp_url, query = gen_otp_data) %>%
read_html() %>%
html_text()
# 개별종목 지표 데이터 다운로드
down_url = 'http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd'
down_ind = POST(down_url, query = list(code = otp)) %>%
read_html(.,encoding='cp949') %>%
html_text() %>%
read_csv()
}
KRXDataMerge<-function(businessDay){
down_sector_KOSPI<-KRXIndStat(businessDay,'STK')
down_sector_KOSDAQ<-KRXIndStat(businessDay,'KSQ')
down_sector<-rbind(down_sector_KOSPI,down_sector_KOSDAQ)
down_monitoring<-KRXMonitoringStat()
down_monitoring$관리종목<-str_replace_all(down_monitoring$관리종목,'O','관리종목')
down_monitoring$관리종목<-str_replace_all(down_monitoring$관리종목,'X','-')
down_monitoring<-down_monitoring[,c(1,2,5)]
down_ind<-KRXIndividualStat(businessDay)
#데이터 정리(개별종목, 산업현황 데이터 병합)
setdiff(down_sector[,'종목명'],down_ind[,'종목명']) #겹치지 않은 종목 ->제외(일반적이지 않은 종목들)
KOR_ticker = merge(down_sector, down_ind,
by = intersect(names(down_sector),names(down_ind)),
all = FALSE
)
KOR_ticker<-merge(KOR_ticker,down_monitoring,by=c("종목코드","종목명"),all=FALSE)
setDT(KOR_ticker)
setorder(KOR_ticker,'시가총액') #시가총액으로 정렬
KOR_ticker <- KOR_ticker[!grepl('스팩', KOR_ticker$'종목명'),]
KOR_ticker <- KOR_ticker[str_sub(KOR_ticker$'종목코드', -1, -1) == 0,] #우선주
KOR_ticker$일자<-as.Date(businessDay,format='%Y%m%d')
KOR_ticker<-subset(KOR_ticker,select = c('일자','종목코드','종목명','시장구분','업종명','종가','시가총액',
'주당배당금','배당수익률','관리종목'))
names(KOR_ticker)<-c('일자','종목코드','종목명','시장구분','산업분류','현재가(종가)','시가총액',
'주당배당금','배당수익률','관리여부')
return(KOR_ticker)
}
WICSSectorInfo<-function(businessDay){
#각 섹터별로 정보 얻기
# 10: 에너지, 15: 소재, 20: 산업재, 25: 경기관련소비재, 30: 필수소비재, 35: 건강관리
# 40: 금융, 45: IT, 50: 커뮤니케이션서비스, 55: 유틸리티
sector_code = c('G25', 'G35', 'G50', 'G40', 'G10',
'G20', 'G55', 'G30', 'G15', 'G45')
data_sector = list()
for (i in sector_code) {
url = paste0(
'http://www.wiseindex.com/Index/GetIndexComponets',
'?ceil_yn=0&dt=',businessDay,'&sec_cd=',i)
data = fromJSON(url)
data = data$list
data_sector[[i]] = data
Sys.sleep(1)
}
data_sector = do.call(rbind, data_sector)
}
#KRX 데이터와 WICS데이터 조인 -> 특정 날에 존재한 기업에 대한 정보 획득
mergeWICSKRX<-function(businessDay){
KRX<-KRXDataMerge(businessDay)
WICS<-WICSSectorInfo(businessDay)[,c(1,2,4)]
table<-merge(WICS,KRX,by.x="CMP_CD",by.y="종목코드")
setnames(table,old=c("CMP_CD","IDX_CD","IDX_NM_KOR"),new=c("종목코드","섹션IDX","섹션"))
return(table)
}
adjustedPriceFromNaver<-function(interval, cnt, code){
# 오류 발생 시 이를 무시하고 다음 루프로 진행
tryCatch({
# url 생성
url = paste0(
'https://fchart.stock.naver.com/sise.nhn?symbol='
,code,'&timeframe=',interval,'&count=',cnt,'&requestType=0')
# 이 후 과정은 위와 동일함
# 데이터 다운로드
data = GET(url)
data_html = read_html(data, encoding = 'EUC-KR') %>%
html_nodes("item") %>%
html_attr("data")
# 데이터 나누기
price = read_delim(data_html, delim = '|')
# 필요한 열만 선택 후 클렌징
price = price[c(1, 5)]
price = data.frame(price)
colnames(price) = c('Date', code)
price[, 1] = ymd(price[, 1])
rownames(price) = price[, 1]
price[, 1] = NULL
return(price)
}, error = function(e) {
# 오류 발생시 해당 종목명을 출력
warning(paste0("Error in Ticker: ", code))
})
}
#각 월별 마지막 거래일 출력
getLastBizdayofMonth<-function(cnt){
return(rownames(adjustedPriceFromNaver('month',cnt,'005930')))
}
#Fnguide에서 데이터 받기
getFSHtmlFromFnGuide<-function(codeList){
htmlData<-list()
i<-1
for(code in codeList){
url = paste0(
'https://comp.fnguide.com/SVO2/ASP/'
,'SVD_Finance.asp?pGB=1&gicode=A',
code)
# 이 후 과정은 위와 동일함
# 데이터 다운로드 후 테이블 추출
data = GET(url) %>%
read_html() %>%
html_table()
htmlData[[code]]<-data
print(paste0(Sys.time()," : [",i,"/",length(codeList),"] Success: ",code))
i<-i+1
}
return(htmlData)
}
#Fnguide에서 받은 데이터 정리하기
cleanFSHtmlToDataFrame<-function(type,htmlData){
if(length(htmlData)==0) return(NULL)
data<-htmlData[[1]]
if(type=="Y") r=1 else r=2
idxList<-0:2*2+r
# 3개 재무제표를 하나로 합치기
data_IS<-data[[idxList[1]]]
data_BS<-data[[idxList[2]]]
data_CF<-data[[idxList[3]]]
data_IS<-data_IS[, 1:(ncol(data_IS)-2)]
data_IS$name<-'포괄손익계산서'
data_BS$name<-'재무상태표'
data_CF$name<-'현금흐름표'
data_fs<-rbind(data_IS,data_BS,data_CF)
# 데이터 클랜징
data_fs[, 1] = gsub('계산에 참여한 계정 펼치기','',data_fs[, 1])
data_fs = data_fs[!duplicated(data_fs[, 1]), ]
rownames(data_fs) = NULL
ftype<-data_fs[,1]
data_fs<-data_fs[,-1]
Name<-data_fs[,length(names(data_fs))]
data_fs<-data_fs[,-length(names(data_fs))]
data_fs = sapply(data_fs, function(x) {
str_replace_all(x, ',', '') %>%
as.numeric()
}) %>%
data.frame(., row.names = rownames(data_fs))
data_fs$'계정'<-ftype
data_fs$code<-names(htmlData)
data_fs$'항목'<-Name
data_fs<-subset(data_fs,select=c(6,7,5,1,2,3,4))
date<-names(data_fs)[4:7]
date<-str_replace_all(date,'[X]','')
names(data_fs)[4:7]<-date
if(type=='Q') {names(data_fs)[4:7]<-date} else{
month<-substr(date,6,7)
if(month[length(date)]!=month[1]) data_fs<-data_fs[,-length(names(data_fs))]
}
data_fs<-as.data.table(data_fs)
data_fs<-melt.data.table(data_fs,1:3)
names(data_fs)<-c("종목코드","종류","계정","일자","값")
data_fs$값<-data_fs$값*100000000
data_fs<-data_fs[!is.na(data_fs$값),]
return(data_fs)
}
getCurrentPrice<-function(code){
url = paste0('https://comp.fnguide.com/SVO2/ASP/SVD_main.asp?pGB=1&gicode=A',code)
data = GET(url)
price = read_html(data) %>%
html_node(xpath = '//*[@id="svdMainChartTxt11"]') %>%
html_text() %>%
parse_number()
return(price)
}
#현재 주식 수
getCurrentStockNumbers<-function(code){
url = paste0('https://comp.fnguide.com/SVO2/ASP/SVD_main.asp?pGB=1&gicode=A',code)
data = GET(url)
share = read_html(data) %>%
html_node(xpath = '//*[@id="svdMainGrid1"]/table/tbody/tr[7]/td[1]') %>%
html_text() %>%
strsplit('/') %>%
unlist() %>%
parse_number()
return(share)
}
#현재 보통주 수
getCurrentOrdinaryStockNumbers<-function(code){
return(getCurrentStockNumbers(code)[1])
}
#현재 우선주 수
getCurrentPreferredStockNumbers<-function(code){
return(getCurrentStockNumbers(code)[2])
}
getPriceList<-function(businessDay, codeList){
result<-c()
for(code in codeList){
result[code]=getCurrentPrice(code)
}
return(result)
}
getStockNumberList<-function(businessDay, codeList){
result<-data.frame(ordinary=double(),preferred=double())
for(code in codeList){
result[code,] <- getCurrentStockNumbers(code)
}
return(result)
}
cleanDataAndExtractEntitiesFromFS<-function(corpData,yearData,quarterData,isNew){
result<-NULL
tryCatch(
{
businessDate<-as.Date(corpData[[1]],format='%Y-%m-%d')
code<-corpData[[2]]
yData<-yearData[종목코드==code]
qData<-quarterData[종목코드==code]
lastYearDate<-businessDate %m+% months(-12)
yData<-yData[등록일자>=lastYearDate]
qData<-qData[등록일자>=lastYearDate]
if(!isNew){
yData<-yData[등록일자<=businessDate]
qData<-qData[등록일자<=businessDate]
}
yDate<-as.character(yData$일자)
qDate<-as.character(qData$일자)
qRank<-frank(-as.double(qDate),ties.method="dense")
yRank<-frank(-as.double(yDate),ties.method="dense")
if(length(yRank) == 0 & length(unique(qRank)) < 4 ){return(result)}
curQRange<-diff(range(as.double(qDate)[qRank<5]))
if(length(unique(qDate))>=4 & curQRange<=1){
data<-qData[qRank<=4]
} else{ data<-yData[yRank==1] }
result <- extractFSEntities(corpData, data)
},
error=function(e) print(paste0("Fail to Read: ",code," Date:",businessDate))
)
return(result)
}
sumQuarterData<-function(data){
fs<-data[data$종류=='재무상태표']
data<-data[data$종류!='재무상태표']
fs<-fs[fs$일자==max(fs$일자)]
fs<-fs[,-c('일자','등록일자')]
if(length(unique(data$일자))>1) data<-data[,.(값=sum(값)),by=c('종목코드','종류','계정')] else{
data<-data[,-c('일자','등록일자')]
}
names(fs)<-names(data)
data<-rbind(data,fs)
return(data)
}
extractFSEntities<-function(corpData,data){
marketPrice<-corpData$시가총액
code<-corpData$종목코드
data<-data[data$종목코드==code]
data<-unique(data,by=c("종목코드","종류","계정","일자"),fromLast=T)
if(length(unique(data$일자))==4){
data<-sumQuarterData(data)
}
#  data[,일자:=corpData[[1]]]
#  data<-subset(data,select=c(5,1,2,3,4))
value_type <- c('지배주주순이익','자본','자본금','영업활동으로인한현금흐름',
'재무활동으로인한현금흐름','투자활동으로인한현금흐름','매출액','매출총이익','영업이익',
'유동자산','부채','유상증자','자산','유동부채','당기순이익')
tmp<-data[data[,계정 %in% value_type]]$값
names(tmp)<-data[data[,계정 %in% value_type]]$계정
corpData[,':='(자산=tmp['자산'],유동자산=tmp['유동자산'],부채=tmp['부채'],유동부채=tmp['유동부채'],
자본=tmp['자본'],자본금=tmp['자본금'],매출액=tmp['매출액'],매출총이익=tmp['매출총이익'],
영업이익=tmp['영업이익'],지배주주순이익=tmp['지배주주순이익'],당기순이익=tmp['당기순이익'],
영업활동으로인한현금흐름=tmp['영업활동으로인한현금흐름'],
재무활동으로인한현금흐름=tmp['재무활동으로인한현금흐름'],
투자활동으로인한현금흐름=tmp['투자활동으로인한현금흐름'],
유상증자=tmp['유상증자'])]
return(corpData)
}
addMomentum<-function(businessDay, codeList){
result<-NULL
for(code in codeList){
tryCatch(
{
priceList<-adjustedPriceFromNaver('day',365,code)
Return<-Return.calculate(priceList)
Return<-Return[!is.na(Return)]
volatility<-sd(Return)*sqrt(length(Return))
monthPrice<-adjustedPriceFromNaver('month',14,code)[,1]
latestValue<-monthPrice[13]
monthlyMomentum<-latestValue/monthPrice[-12:-13]-1
avgMomentum<-(mean(monthlyMomentum))/volatility
result2<-rbind(result,unlist(c('종목코드'=code,Momentum=avgMomentum)))
Sys.sleep(0.3)
},
error=function(e) print(paste0("Fail to Read: ",code))
)
}
return(result)
}
winsorizing<-function(val){
newval<-ifelse(percent_rank(val)>0.99,
quantile(val,0.99,na.rm=TRUE),val)
return(newval)
}
down_monitoring<-KRXMonitoringStat()
down_monitoring
# 개별종목 지표 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
# 산업별 현황 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
gen_otp_data = list(
mktId = 'ALL',
trdDd = businessDay,
money = '1',
csvxls_isNo = 'false',
name = 'fileDown',
url='dbms/MDC/STAT/standard/MDCSTAT03901'
)
businessDay<-'20210817'
# 산업별 현황 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
gen_otp_data = list(
mktId = 'ALL',
trdDd = businessDay,
money = '1',
csvxls_isNo = 'false',
name = 'fileDown',
url='dbms/MDC/STAT/standard/MDCSTAT03901'
)
otp = POST(gen_otp_url, query = gen_otp_data) %>%
read_html() %>%
html_text()
otp
# 산업별 현황 데이터 다운로드
down_url = 'http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd'
down_sector = POST(down_url, query = list(code = otp)) %>%
read_html(.,encoding='cp949') %>%
html_text() %>%
read_csv()
POST(down_url, query = list(code = otp))
down_sector = POST(down_url, query = list(code = otp)) %>%
read_html(.,encoding='cp949')
down_sector
KRXMonitoringStat()
a<-KRXMonitoringStat()
a
down_ind<-KRXIndividualStat(businessDay)
down_ind
down_sector_KOSPI<-KRXIndStat(businessDay,'STK')
down_sector_KOSDAQ<-KRXIndStat(businessDay,'KSQ')
down_sector<-rbind(down_sector_KOSPI,down_sector_KOSDAQ)
down_sector
down_monitoring<-KRXMonitoringStat()
down_monitoring$관리종목<-str_replace_all(down_monitoring$관리종목,'O','관리종목')
down_monitoring$관리종목<-str_replace_all(down_monitoring$관리종목,'X','-')
down_monitoring<-down_monitoring[,c(1,2,5)]
down_ind<-KRXIndividualStat(businessDay)
down_ind
#데이터 정리(개별종목, 산업현황 데이터 병합)
setdiff(down_sector[,'종목명'],down_ind[,'종목명']) #겹치지 않은 종목 ->제외(일반적이지 않은 종목들)
KOR_ticker = merge(down_sector, down_ind,
by = intersect(names(down_sector),names(down_ind)),
all = FALSE
)
KOR_ticker
down_sector
down_ind
merge(down_sector, down_ind,
by = intersect(names(down_sector),names(down_ind)),
all = FALSE
)
names(down_sector)
names(down_ind)
?setdiff
?html_table
library(rvest)
?html_table
html_table
a<-c()
a<-c(a,1)
a
a<-c(a,2)
a
a<-c(a,3)
a<-c(a,3)
a
length(a)
=======
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-ratio)]
balanceCombinedTable[,outsideofBand:=diffRatio>ratio*bandLimit]
balanceCombinedTable
balanceCombinedTable[,sum(targetBalance)]
minimumOrder<-getMinimumOrderUnit(balanceCombinedTable$market)
balanceCombinedTable<-merge(balanceCombinedTable,minimumOrder,by.x="market",by.y="market",all=TRUE)
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(targetBalance)]$targetBalance<-0
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,diff:=targetBalance-balance]
balanceCombinedTable[diff<0][diff>ask_min]$targetBalance<-balanceCombinedTable[diff<0][diff>ask_min]$balance
balanceCombinedTable[diff>0][diff<bid_min]$targetBalance<-balanceCombinedTable[diff>0][diff<bid_min]$balance
balanceCombinedTable[,diff:=targetBalance-balance]
balanceCombinedTable[,sellall:=targetBalance==0]
totalBalance<-balanceCombinedTable[,sum(targetBalance)]
totalBalance
remainedBalance<-totalBalance-balanceCombinedTable[diff==0][,sum(balance)]
remainedBalance
balanceCombinedTable[diff!=0]$targetBalance<-balanceCombinedTable[diff!=0][,ratio/sum(ratio)]*remainedBalance
balanceCombinedTable[,diff:=targetBalance-balance]
balanceCombinedTable
balanceCombinedTable[,sum(targetBalance)]
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
#setwd("C:/Users/vicen/Documents/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-5
coinNumLimit<-100
bandLimit<-0.3
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1. 전체 시장의 모멘텀 계산(3개월로 계산)
#전체 시장에서 상승하는 모멘텀의 개수비율로 코인과 현금의 비중 조절
#시총 상위 100개의 코인으로 모멘텀 계산산
#현금비중=100-margetStrength
momentumList<-getUpbitCoinMomentum("days","",100, coinList$symbol)
marketStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
#모멘텀 방식: 0 ~ 50%, 인덱스: 나머지
#지금 1달 간의 모멘텀 계산
#상위 5개의 코인 매입
momentumList<-getUpbitCoinMomentum("days","",30,getUpbitCoinList()$market)
momentumStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
momentumRatioLimit<-marketStrength*momentumStrength*0.5
momentumCoin<-getMomentumBalance(coinList,num,momentumRatioLimit,"EQUAL",momentumList)
#인덱스
#5개의 코인 구입
#비율:
indexLimitRatio <- marketStrength-momentumRatioLimit
indexCoin<-getIndexBalance(coinList[1:num,],indexLimitRatio,"MARKET")
coinMomentumUnionTable<-rbind(indexCoin,momentumCoin)
coinMomentumUnionTable<-coinMomentumUnionTable[,.(ratio=sum(ratio)),by=c("symbol","market","market_cap")]
#totalBalance<-sum(currentBalance$balance)
balanceCombinedTable<-merge(coinMomentumUnionTable,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-ratio)]
balanceCombinedTable[,outsideofBand:=diffRatio>ratio*bandLimit]
if(sum(balanceCombinedTable$outsideofBand)){
orderTable<-createOrderTable(balanceCombinedTable)
rebalanceTable(orderTable)
} else{
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
log_print("Every coins are in the band. Buy Nothing")
log_close()
}
setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
pkg = c('quantmod','jsonlite', 'stringr', 'logr',
'jose','openssl','PerformanceAnalytics','xts','curl','data.table',
'httr')
new.pkg = pkg[!(pkg %in% installed.packages()[, "Package"])]
#logDir<-"/home/pi/stockInfoCrawler/StockTradebot/log"
logDir<-"C:/coinTestLog"
if (length(new.pkg)) {
install.packages(new.pkg, dependencies = TRUE)}
sapply(pkg,library,character.only=T)
getCoinMarketCapList<-function(num){
coinMarket_api_key<-fromJSON("./config.json")$coinmarketcap_key$api_key
url<-paste0("https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?limit=",num)
h<-new_handle()
handle_setheaders(h, .list=list("X-CMC_PRO_API_KEY"=coinMarket_api_key, Accepts="application/json"))
r <- curl_fetch_memory(url, h)
result<-fromJSON(rawToChar(r$content))$data
priceList<-result$quote$USD
coinMarketTable<-data.table(name=result$name,symbol=result$symbol,priceList)
return(coinMarketTable[order(-market_cap)])
}
getUpbitCoinList<-function(){
url<-'https://api.upbit.com/v1/market/all?isDetails=false'
h<-new_handle()
handle_setheaders(h, .list=list(Accepts="application/json"))
r <- curl_fetch_memory(url, h)
upbitCoinTable<-rawToChar(r$content)
Encoding(upbitCoinTable)<-"UTF-8"
upbitCoinTable<-as.data.table(fromJSON(upbitCoinTable))
upbitCoinTable<-upbitCoinTable[substr(market,1,3)=="KRW"]
upbitCoinTable[,market:=str_replace(market,"KRW-","")]
return(upbitCoinTable)
}
getUpbitCoinListDetail<-function(num){
coinMarketCapTable<-getCoinMarketCapList(num)
#coinMarketCapTable$name<-toupper(coinMarketCapTable$name)
upbitCoinTable<-getUpbitCoinList()
#upbitCoinTable$english_name<-toupper(upbitCoinTable$english_name)
coinTable<-coinMarketCapTable[upbitCoinTable,on=c(symbol="market")]
coinTable<-coinTable[order(-market_cap)]
coinTable<-unique(coinTable,fromLast=FALSE,by="symbol")
coinTable<-na.omit(coinTable)
coinTable<-subset(coinTable,select=-english_name)
return(coinTable)
}
getTopNUpbitCoinList<-function(coinLimit, num){
return(getUpbitCoinListDetail(coinLimit)[1:num,])
}
createJwtToken<-function(query,random){
upbitConfig<-fromJSON("./config.json")$upbit_key
uuid<-as.character(as.numeric(Sys.time())*random)
query_hash_alg<-"SHA512"
if(is.null(query)){
jwtClaim<-jwt_claim(access_key=upbitConfig$access_key,nonce=uuid)
jwtToken<-jwt_encode_hmac(jwtClaim,upbitConfig$secret_key,256)
} else{
q<-as.character(sha512(query))
jwtClaim<-jwt_claim(iat=NULL,
access_key=upbitConfig$access_key,
nonce=uuid,
query_hash=q,
query_hash_alg=query_hash_alg)
jwtToken<-jwt_encode_hmac(jwtClaim,upbitConfig$secret_key,256)
}
return(jwtToken)
}
getResponseParam<-function(url, query){
jwtToken<-createJwtToken(query,runif(1,1000,23455))
h<-new_handle()
handle_setheaders(h, .list=list(Accept="application/json",
Authorization=paste0("Bearer ",jwtToken)))
return(fromJSON(rawToChar(curl_fetch_memory(url, h)$content)))
}
getCurrentUpbitAccountInfo<-function(){
url<-"https://api.upbit.com/v1/accounts"
result<-getResponseParam(url,NULL)
result$balance<-as.numeric(result$balance)
result$avg_buy_price<-as.numeric(result$avg_buy_price)
setDT(result)
return(result)
}
getCurrentUpbitPrice<-function(coinList){
krwCoinString=paste(coinList,collapse=',')
url <- paste0('https://api.upbit.com/v1/ticker?markets=',krwCoinString,'&count=',1)
h<-new_handle()
handle_setheaders(h, .list=list(Accepts="application/json"))
priceList<-as.data.table(fromJSON(rawToChar(curl_fetch_memory(url, h)$content)))
priceList<-priceList[,.(market,trade_price)]
priceList[,trade_price:=as.double(trade_price)]
return(priceList)
}
getCoinPriceHistory<-function(coinList,type,unit,count){
#type: minutes, days, weeks, months
#unit: 분봉(minutes), 상관없음(others)
#coinList<-paste("KRW",coinList,sep="-")
if(type=="minutes") {
candle<-paste0("minutes/",unit)
} else {candle<-type}
url <- paste0('https://api.upbit.com/v1/candles/'
,candle,'?market=',coinList,'&count=',count)
h<-new_handle()
handle_setheaders(h, .list=list(Accepts="application/json"))
res<-list()
for(u in url){
res[[u]] <- fromJSON(rawToChar(curl_fetch_memory(u, h)$content))
Sys.sleep(0.1)
}
return(rbindlist(res))
}
getMomentumHistory<-function(coinList,candleType,unit,count,priceType,momentumPeriod){
#priceType: opening_price, high_price, low_price, trade_price
priceList<-getCoinPriceHistory(coinList,candleType,unit,count)
priceList<-subset(priceList,select=c("market","candle_date_time_kst",priceType))
priceList[,prevPrice:=shift(get(priceType),momentumPeriod,NA,"lead"),by=market]
priceList<-na.omit(priceList)
priceList[,momentum:=get(priceType)/prevPrice*100]
return(subset(priceList,select=c("market","candle_date_time_kst","momentum")))
}
getUpbitCoinMomentum<-function(candleType,unit,momentumPeriod, coinList){
coinList<-paste("KRW",coinList,sep="-")
momentum<-getMomentumHistory(coinList,candleType,unit,momentumPeriod+1,"trade_price",momentumPeriod)
return(momentum)
}
getCurrentBalance<-function(){
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
log_print("CURRENT BALANCE")
krwCoinList<-getUpbitCoinList()
balanceList<-getCurrentUpbitAccountInfo()
KRWRow<-balanceList[1,]
balanceList<-merge(balanceList,krwCoinList[,1],by.x="currency",by.y="market")
balanceList<-rbind(KRWRow,balanceList)
log_print(balanceList)
balanceList[,market:=paste0("KRW-",currency)]
log_print("CURRENT COIN PRICE")
price=getCurrentUpbitPrice(balanceList$market[-1])
price<-rbind(price,as.list(c("KRW-KRW",1)))
balanceList<-merge(balanceList,price,by.x="market",by.y="market")
balanceList[,trade_price:=as.double(trade_price)]
curBalanceList<-balanceList[,.(market,currency,balance=balance*trade_price,curvolume=balance)]
return(curBalanceList)
}
getMomentumBalance<-function(coinList,num,limitRatio,type,momentumList){
momentumList[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
momentumList <- coinList[momentumList,on=c("symbol")]
momentumList <- coinList[momentumList,on=c("symbol")]
momentumList<-momentumList[order(-momentum)]
momentumList<-momentumList[,.(symbol,market,market_cap)]
if(type=="MARKET"){
momentumList<-na.omit(momentumList)
momentumList[,ratio:=market_cap/sum(market_cap)*limitRatio]
} else if(type=="EQUAL"){
momentumList[,ratio:=1/num*limitRatio]
}
return(momentumList[1:num,])
}
getIndexBalance<-function(coinList, limitRatio, type){
coinList[,market:=paste0("KRW-",symbol)]
coinList<-coinList[,.(symbol,market,market_cap)]
num<-NROW(coinList)
if(type=="MARKET"){
coinList[,ratio:=market_cap/sum(market_cap)*limitRatio]
} else if(type=="EQUAL"){
coinList[,ratio:=1/num*limitRatio]
}
return(coinList)
}
createOrderTable<-function(balanceCombinedTable){
minimumOrder<-getMinimumOrderUnit(balanceCombinedTable$market)
balanceCombinedTable<-merge(balanceCombinedTable,minimumOrder,by.x="market",by.y="market",all=TRUE)
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(targetBalance)]$targetBalance<-0
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,diff:=targetBalance-balance]
balanceCombinedTable[diff<0][diff>ask_min]$targetBalance<-balanceCombinedTable[diff<0][diff>ask_min]$balance
balanceCombinedTable[diff>0][diff<bid_min]$targetBalance<-balanceCombinedTable[diff>0][diff<bid_min]$balance
balanceCombinedTable[,diff:=targetBalance-balance]
balanceCombinedTable[,sellall:=targetBalance==0]
totalBalance<-balanceCombinedTable[,sum(targetBalance)]
remainedBalance<-totalBalance-balanceCombinedTable[diff==0][,sum(balance)]
if(remainedBalance!=totalBalance){
balanceCombinedTable[diff!=0]$targetBalance<-balanceCombinedTable[diff!=0][,ratio/sum(ratio)]*remainedBalance
balanceCombinedTable[,diff:=targetBalance-balance]
}
balanceCombinedTable<-balanceCombinedTable[,.(market,diff,curvolume,sellall)]
names(balanceCombinedTable)<-c("market","buyamount","currentvolume","sellall")
return(balanceCombinedTable)
}
rebalanceTable<-function(table){
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
table<-table[buyamount!=0]
table$ord_type<-'limit'
table$side<-'bid'
table[buyamount<0]$side<-'ask'
table[,buyamount:=abs(buyamount)]
table[,price:=getCurrentUpbitPrice(table$market)$trade_price]
table[,volume:=buyamount/price]
table[sellall==T]$volume<-table[sellall==T]$currentvolume
table[side=="ask"][currentvolume<volume]$volume<-table[side=="ask"][currentvolume<volume]$currentvolume
log_open()
table<-subset(table,select=c("market","side","volume","price","ord_type"))
log_print("Final Table List")
log_print(table)
log_close()
if(NROW(table[side=="ask"])>0){
orderCoin(table[side=="ask"])
Sys.sleep(2)
}
orderCoin(table[side=="bid"])
}
orderCoin<-function(order){
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x,runif(1,1000,33553)))
url<-"https://api.upbit.com/v1/orders"
for(i in 1:NROW(order)){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",tokenList[i])),body=as.list(order[i,]),encode='json')
log_print(query[i])
log_print(res$status_code)
log_print(rawToChar(res$content))
Sys.sleep(0.3)
}
}
getMinimumOrderUnit<-function(coinList){
table<-NULL
query<-paste0("market=",coinList)
tokenList<-sapply(query,function(x) createJwtToken(x,runif(1,1000,33553)))
url<-paste0("https://api.upbit.com/v1/orders/chance?",query)
for(i in 1:length(coinList)){
res<-GET(url[i],add_headers(Authorization=paste0("Bearer ",tokenList[i])))
if(res$status_code==200){
list<-fromJSON(rawToChar(res$content))
table<-rbind(table,c(coinList[i],list$market$ask$min_total,list$market$bid$min_total))
}
}
table<-as.data.table(table)
names(table)<-c("market","ask_min","bid_min")
table[,ask_min:=as.double(ask_min)]
table[,bid_min:=as.double(bid_min)]
table[,ask_min:=-ask_min]
return(table)
}
>>>>>>> 6ddb66a2d1c351f6015746ea679e5a997fc78303
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
#setwd("C:/Users/vicen/Documents/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-5
coinNumLimit<-100
bandLimit<-0.3
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
coinList
#1. 전체 시장의 모멘텀 계산(3개월로 계산)
#전체 시장에서 상승하는 모멘텀의 개수비율로 코인과 현금의 비중 조절
#시총 상위 100개의 코인으로 모멘텀 계산
#현금비중=100-margetStrength
momentumList<-getUpbitCoinMomentum("days","",c(100),c(1), coinList$symbol)
momentumList
marketStrength<-min(0.95,NROW(momentumList[momentum>100])/NROW(momentumList))
marketStrength
#모멘텀 방식: 0 ~ 50%, 인덱스: 나머지
#지금 1달 간의 모멘텀 계산
#상위 5개의 코인 매입
momentumList<-getUpbitCoinMomentum("days","",c(10,20,30),c(0.5,0.3,0.2),getUpbitCoinList()$market)
momentumStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
momentumStrength
momentumRatioLimit<-min(marketStrength*momentumStrength,0.6)
momentumRatioLimit
#인덱스
#5개의 코인 구입
#비율:
indexLimitRatio <- marketStrength-momentumRatioLimit
indexLimitRatio
indexCoin<-getIndexBalance(coinList[1:num,],indexLimitRatio,"MARKET")
<<<<<<< HEAD
indexCoin
indexCoin
momentumRatioLimit<-min(marketStrength*momentumStrength,marketStrength*0.6)
momentumRatioLimit
marketStrength*momentumStrength
marketStrength*0.6
marketStrength
marketStrength*0.5
=======
coinMomentumUnionTable<-rbind(indexCoin,momentumCoin)
coinMomentumUnionTable<-coinMomentumUnionTable[,.(ratio=sum(ratio)),by=c("symbol","market","market_cap")]
#totalBalance<-sum(currentBalance$balance)
balanceCombinedTable<-merge(coinMomentumUnionTable,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-ratio)]
balanceCombinedTable[,outsideofBand:=diffRatio>ratio*bandLimit]
if(sum(balanceCombinedTable$outsideofBand)){
orderTable<-createOrderTable(balanceCombinedTable)
rebalanceTable(orderTable)
} else{
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
log_print("Every coins are in the band. Buy Nothing")
log_close()
}
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
#setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
setwd("C:/Users/vicen/Documents/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-5
coinNumLimit<-100
bandLimit<-0.5
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1. 전체 시장의 모멘텀 계산(3개월로 계산)
#전체 시장에서 상승하는 모멘텀의 개수비율로 코인과 현금의 비중 조절
#시총 상위 100개의 코인으로 모멘텀 계산산
#현금비중=100-margetStrength
momentumList<-getUpbitCoinMomentum("days","",c(100),c(1), coinList$symbol)
marketStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
#모멘텀 방식: 0 ~ 50%, 인덱스: 나머지
#지금 1달 간의 모멘텀 계산
#상위 5개의 코인 매입
momentumList<-getUpbitCoinMomentum("days","",c(10,20,30),c(0.5,0.3,0.2),getUpbitCoinList()$market)
momentumStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
momentumRatioLimit<-marketStrength*momentumStrength*0.5
momentumCoin<-getMomentumBalance(coinList,num,momentumRatioLimit,"EQUAL",momentumList)
#인덱스
#5개의 코인 구입
#비율:
indexLimitRatio <- marketStrength-momentumRatioLimit
indexCoin<-getIndexBalance(coinList[1:num,],indexLimitRatio,"MARKET")
coinMomentumUnionTable<-rbind(indexCoin,momentumCoin)
coinMomentumUnionTable<-coinMomentumUnionTable[,.(ratio=sum(ratio)),by=c("symbol","market","market_cap")]
coinMomentumUnionTable
balanceCombinedTable<-merge(coinMomentumUnionTable,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-ratio)]
balanceCombinedTable[,outsideofBand:=diffRatio>ratio*bandLimit]
failOrder<-c()
orderTable<-createOrderTable(balanceCombinedTable)
orderTable
table<-orderTable
table<-table[buyamount!=0]
table$ord_type<-'limit'
table$side<-'bid'
table[buyamount<0]$side<-'ask'
table[,buyamount:=abs(buyamount)]
table[,price:=getCurrentUpbitPrice(table$market)$trade_price]
table[,volume:=buyamount/price]
table[sellall==T]$volume<-table[sellall==T]$currentvolume
table[side=="ask"][currentvolume<volume]$volume<-table[side=="ask"][currentvolume<volume]$currentvolume
log_open()
table<-subset(table,select=c("market","side","volume","price","ord_type"))
log_print("Final Table List")
log_print(table)
log_close()
coinMomentumUnionTable
a<-c("KRW-BTC","KRW_ETH")
coinMomentumUnionTable[market %in% a]
a<-c("KRW-BTC","KRW-ETH")
coinMomentumUnionTable[market %in% a]
coinMomentumUnionTable[market %in% c()]
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
#setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
setwd("C:/Users/vicen/Documents/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-5
coinNumLimit<-100
bandLimit<-0.5
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1. 전체 시장의 모멘텀 계산(3개월로 계산)
#전체 시장에서 상승하는 모멘텀의 개수비율로 코인과 현금의 비중 조절
#시총 상위 100개의 코인으로 모멘텀 계산산
#현금비중=100-margetStrength
momentumList<-getUpbitCoinMomentum("days","",c(100),c(1), coinList$symbol)
marketStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
marketStrength
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
#setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
setwd("C:/Users/vicen/Documents/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-5
coinNumLimit<-100
bandLimit<-0.5
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1. 전체 시장의 모멘텀 계산(3개월로 계산)
#전체 시장에서 상승하는 모멘텀의 개수비율로 코인과 현금의 비중 조절
#시총 상위 100개의 코인으로 모멘텀 계산산
#현금비중=100-margetStrength
momentumList<-getUpbitCoinMomentum("days","",c(100),c(1), coinList$symbol)
marketStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
momentumStrength<-NROW(momentumList[momentum>100])/NROW(momentumList)
momentumRatioLimit<-marketStrength*momentumStrength*0.5
momentumCoin<-getMomentumBalance(coinList,num,momentumRatioLimit,"EQUAL",momentumList)
indexCoin<-getIndexBalance(coinList[1:num,],indexLimitRatio,"MARKET")
coinMomentumUnionTable<-rbind(indexCoin,momentumCoin)
coinMomentumUnionTable<-coinMomentumUnionTable[,.(ratio=sum(ratio)),by=c("symbol","market","market_cap")]
#모멘텀 방식: 0 ~ 50%, 인덱스: 나머지
#지금 1달 간의 모멘텀 계산
#상위 5개의 코인 매입
momentumList<-getUpbitCoinMomentum("days","",c(10,20,30),c(0.5,0.3,0.2),getUpbitCoinList()$market)
#인덱스
#5개의 코인 구입
#비율:
indexLimitRatio <- marketStrength-momentumRatioLimit
#인덱스
#5개의 코인 구입
#비율:
indexLimitRatio <- marketStrength-momentumRatioLimit
indexCoin<-getIndexBalance(coinList[1:num,],indexLimitRatio,"MARKET")
coinMomentumUnionTable<-rbind(indexCoin,momentumCoin)
coinMomentumUnionTable<-coinMomentumUnionTable[,.(ratio=sum(ratio)),by=c("symbol","market","market_cap")]
coinMomentumUnionTable
#totalBalance<-sum(currentBalance$balance)
balanceCombinedTable<-merge(coinMomentumUnionTable,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-ratio)]
balanceCombinedTable[,outsideofBand:=diffRatio>ratio*bandLimit]
balanceCombinedTable
sum(balanceCombinedTable$outsideofBand)
marketStrength
momentumRatioLimit
indexLimitRatio
>>>>>>> 6ddb66a2d1c351f6015746ea679e5a997fc78303
