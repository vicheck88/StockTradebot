r<-orderStock(apiConfig,account,token,code,qty,price)
print(paste("rc_cd:",r$rt_cd," msg_cd:",r$msg_cd," msg:",r$msg1))
res<-rbind(res,as.data.table(r))
Sys.sleep(0.1)
}
revokeToken(apiConfig,account,token)
return(res)
}
sellSheet<-combinedSheet[평가금액>목표금액]
sellRes<-orderStocks(apiConfig,account,sellSheet) #매도 먼저
sellRes
sellRes[rc_cd!=0]
sellRes[rt_cd!=0]
sellRes[rt_cd!=0 && msg_cd!='APBK0066']
sellRes[rt_cd!=0 & msg_cd!="APBK0066"]
which(sellRes[rt_cd!=0 & msg_cd!="APBK0066"])
which(sellRes[rt_cd!=0 & msg_cd!="APBK0066"r])
r
as.data.table(r)
r$code<-'123456'
r
orderStock<-function(apiConfig,account,token,code,qty,price){
if(qty==0) return(NULL)
if(qty>0) tr_id=apiConfig$buyTrid
if(qty<0) tr_id=apiConfig$sellTrid
#print(tr_id)
orderUrl<-paste0(apiConfig$url,'/uapi/domestic-stock/v1/trading/order-cash') #현금주문
headers<-c(
Authorization=paste('Bearer',token),
appkey=account$appkey,
appsecret=account$appsecret,
tr_id=tr_id
)
body<-list(CANO=substr(account$accNo,1,8),
ACNT_PRDT_CD=substr(account$accNo,9,10),
PDNO=code,
ORD_DVSN='00',
ORD_QTY=as.character(abs(qty)),
ORD_UNPR=as.character(price)
)
response<-POST(orderUrl,add_headers(headers),body=toJSON(body,auto_unbox=T))
res<-fromJSON(rawToChar(response$content))
res$code<-code
res$qty<-qty
res$price<-price
return(res)
}
orderStocks<-function(apiConfig, account, stockTable){
if(nrow(stockTable)==0) return(NULL)
token<-getToken(apiConfig,account)
res<-NULL
for(i in 1:nrow(stockTable)){
code<-stockTable[i,]$종목코드
price<-getCurrentPrice(apiConfig,account,token,code)
curQty<-stockTable[i,]$보유수량
priceSum<-stockTable[i,]$목표금액-price*curQty
qty<-floor(priceSum/price)
print(paste("code:",code," name:",stockTable[i,]$종목명," qty:",qty," price:",price, " ordersum:",qty*price))
if(qty==0){
print("skip order: qty is 0")
next;
}
r<-orderStock(apiConfig,account,token,code,qty,price)
print(paste("rc_cd:",r$rt_cd," msg_cd:",r$msg_cd," msg:",r$msg1))
res<-rbind(res,as.data.table(r))
Sys.sleep(0.1)
}
revokeToken(apiConfig,account,token)
return(res)
}
sellSheet<-combinedSheet[평가금액>목표금액]
sellRes<-orderStocks(apiConfig,account,sellSheet) #매도 먼저
sellRes
selres[rt_cd!=0]
sellRes[rt_cd!=0]
sellRes[rt_cd!='0']
sellRes[rt_cd!='1']
sellRes[rt_cd=='0']
sellRes[rt_cd==1]
summary(sellRes)
failedStocks<-buyRes[rt_cd!='0']
rownames(sellRes)
sellReds
sellRes
sellRes[1,2,3,]
sellRes[1:3,]
rownames(sellRes[1:3,])
rownames(sellRes[2:5,])
buySheet<-combinedSheet[평가금액<목표금액]
buyRes<-orderStocks(apiConfig,account,buySheet) #매수 다음
buyRes
buySheet[buyRes[rt_cd!='0']$idx]
orderStocks<-function(apiConfig, account, stockTable){
if(nrow(stockTable)==0) return(NULL)
token<-getToken(apiConfig,account)
res<-NULL
for(i in 1:nrow(stockTable)){
code<-stockTable[i,]$종목코드
price<-getCurrentPrice(apiConfig,account,token,code)
curQty<-stockTable[i,]$보유수량
priceSum<-stockTable[i,]$목표금액-price*curQty
qty<-floor(priceSum/price)
print(paste("code:",code," name:",stockTable[i,]$종목명," qty:",qty," price:",price, " ordersum:",qty*price))
if(qty==0){
print("skip order: qty is 0")
next;
}
r<-orderStock(apiConfig,account,token,code,qty,price)
r$idx<-i
print(paste("rc_cd:",r$rt_cd," msg_cd:",r$msg_cd," msg:",r$msg1))
res<-rbind(res,as.data.table(r))
Sys.sleep(0.1)
}
revokeToken(apiConfig,account,token)
return(res)
}
buyRes<-orderStocks(apiConfig,account,buySheet) #매수 다음
buySheet[buyRes[rt_cd!='0']$idx]
buyRes[rt_cd!='0']$idx
buySheet[c(13,5)]
buySheet[c(1,3,5)]
buyRes
cnt<-0
failNum<-buyRes[rt_cd!='0']
while(failNum>0 | cnt<=10){
cnt<-cnt+1
rebuySheet<-buySheet[buyRes[rt_cd!='0']$idx]
rebuyRes<-orderStocks(apiConfig,account,rebuySheet)
failNum<-rebuyRes[rt_cd!='0']
}
failNum
failNum<-buyRes[rt_cd!='0']
failNum<-nrow(buyRes[rt_cd!='0'])
while(failNum>0 | cnt<=10){
cnt<-cnt+1
rebuySheet<-buySheet[buyRes[rt_cd!='0']$idx]
rebuyRes<-orderStocks(apiConfig,account,rebuySheet)
failNum<-nrow(rebuyRes[rt_cd!='0'])
}
cnt
failNum
while(failNum>0 & cnt<=2){
cnt<-cnt+1
rebuySheet<-buySheet[buyRes[rt_cd!='0']$idx]
rebuyRes<-orderStocks(apiConfig,account,rebuySheet)
failNum<-nrow(rebuyRes[rt_cd!='0'])
}
cnt<-0
failNum<-nrow(buyRes[rt_cd!='0'])
while(failNum>0 & cnt<=2){
cnt<-cnt+1
rebuySheet<-buySheet[buyRes[rt_cd!='0']$idx]
rebuyRes<-orderStocks(apiConfig,account,rebuySheet)
failNum<-nrow(rebuyRes[rt_cd!='0'])
}
source("~/StockTradebot/Rscript/Han2FunctionList.R") #macOS에서 읽는 경우
#source("~/stockInfoCrawler/StockTradebot/Rscript/Han2FunctionList.R") #라즈베리에서 읽는 경우
pkg = c('RPostgres', 'DBI','stringr')
new.pkg = pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg)) {
install.packages(new.pkg, dependencies = TRUE)}
sapply(pkg,library,character.only=T)
config<-fromJSON("~/config.json")
dbconfig<-config$database
conn<-dbConnect(RPostgres::Postgres(),dbname=dbconfig$database,host=dbconfig$host,port=dbconfig$port,user=dbconfig$user,password=dbconfig$passwd)
#apiConfig<-config$api$config$dev
apiConfig<-config$api$config$prod
#account<-config$api$account$dev
account<-config$api$account$prod$main
#재무제표 이상한 기업 우선 거르기
#최근 2년 간 분기재무제표에서 매출, 매출원가가 음수인 경우가 한 번이라도 있다면 목록에서 제거
prevDate<-str_replace(substring(Sys.Date()-730,1,7),'-','.')
sql<-sprintf("select * from metainfo.월별기업정보 a
where 일자=(select max(일자) from metainfo.월별기업정보)
and not exists (
select 1 from metainfo.분기재무제표 c
where 일자>'%s'
and (계정='매출액' or 계정='매출원가')
and 값<0 and a.종목코드=c.종목코드
)",prevDate)
corpTable<-dbGetQuery(conn,SQL(sql))
setDT(corpTable)
filter<-function(data){
dat<-data[관리여부!="관리종목"]
dat<-dat[is.na(매출총이익)==F]
dat<-dat[is.na(영업활동으로인한현금흐름)==F]
dat<-dat[is.na(자산)==F]
dat<-dat[매출액>=매출총이익] #매출원가가 -인 경우 제외
dat<-dat[자본>자본금] #자본잠식상태가 아님
dat<-dat[영업활동으로인한현금흐름>0]
dat<-dat[매출총이익>0]
dat<-dat[is.na(유상증자)] #최근 1년간 유상증자 안함
return(dat)
}
orderData<-function(data){
data[,SIZERANK:=rank(시가총액)]
data[,QUALITYRANK:=rank(-(매출총이익+영업활동으로인한현금흐름)/자산)]
data[,VALUERANK:=0]
data[,MOMENTUMRANK:=0]
data[,TOTALRANK:=QUALITYRANK+SIZERANK+VALUERANK+MOMENTUMRANK]
setorder(data,TOTALRANK,QUALITYRANK,SIZERANK)
return(data)
}
stocknum<-15
goalBalanceSum<-63000000
output<-filter(corpTable)
output<-orderData(output)
output<-output[1:stocknum]
output$일자<-as.character(output$일자)
print("Selected stocks")
print(output)
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("/Users/chhan/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-1
coinNumLimit<-1
bandLimit<-0.3
changeThreshold<-0.05
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1.가장 시가총액이 높은 두 코인의 이동평균선 계산
#시가총액 비율:
indexCoin<-getIndexBalance(coinList[1:num,],1,"MARKET")
#이평선
type<-"days"
movingAvgDay<-30
unit<-60
count<-200
coinPriceHistory<-getCoinPriceHistory(indexCoin$market,type,unit,count)
coinPriceHistory<-coinPriceHistory[,.(market,candle_date_time_kst,trade_price)]
#현재가격 추가하기
curCoinPrices<-getCurrentUpbitPrice(indexCoin$market)
curCoinPrices[,candle_date_time_kst:=format(Sys.time(),'%Y-%m-%dT%H:%M:%S')]
coinPriceHistory<-rbind(coinPriceHistory,curCoinPrices)
setkeyv(coinPriceHistory,c("market","candle_date_time_kst"))
#이동평균선 구하기
movingAvg<-coinPriceHistory[,.(movingAvg=rollmean(trade_price,movingAvgDay)),by=market]
movingAvg<-movingAvg[,.(movingAvg=c(rep(NA,count+1-.N),movingAvg)),by=market]
coinPriceHistory<-cbind(coinPriceHistory,movingAvg=movingAvg$movingAvg)
coinPriceHistory[,disparity:=trade_price/movingAvg*100-100]
coinPriceHistory<-na.omit(coinPriceHistory)
getInvestRatio<-function(table){
for(i in 1:nrow(table)){
disparity<-table[i,]$disparity
if(disparity>0) {
addRatio<-floor(disparity)*0.5
}  else addRatio<-floor(disparity)*0.25
if(i>1){
prevRatio<-table[i-1,]$investRatio
if(addRatio>=0) addRatio<-max(prevRatio,addRatio)
if(addRatio<0) addRatio<-min(1+addRatio,prevRatio)
}
newRatio<-min(1,addRatio)
newRatio<-max(0,newRatio)
table$investRatio[i]<-newRatio
}
return(table)
}
coinPriceHistory<-coinPriceHistory[,getInvestRatio(.SD),by=market]
coinPriceHistory
currentRatio<-coinPriceHistory[,tail(.SD,1),by=market][,.(market,investRatio)]
failOrder<-c()
balanceCombinedTable<-merge(currentRatio,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(investRatio)]$investRatio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*investRatio]
balanceCombinedTable[,curRatio:=balance/totalBalance]
balanceCombinedTable[,diffRatio:=abs(curRatio-investRatio)]
balanceCombinedTable
balanceCombinedTable<-merge(currentRatio,currentBalance,by="market",all=TRUE)
balanceCombinedTable
currentRatio
balanceCombinedTable<-merge(currentRatio,currentBalance,by="market",all=TRUE)
balanceCombinedTable
currentBalance
balanceCombinedTable<-merge(currentRatio,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable
balanceCombinedTable[is.na(investRatio)]$investRatio<-0
balanceCombinedTable
balanceCombinedTable<-merge(currentRatio,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(investRatio)]$investRatio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*investRatio]
balanceCombinedTable
orderTable<-createOrderTable(balanceCombinedTable)
minimumOrder<-getMinimumOrderUnit(balanceCombinedTable$market)
balanceCombinedTable<-merge(balanceCombinedTable,minimumOrder,by.x="market",by.y="market",all=TRUE)
balanceCombinedTable
minimumOr
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("/Users/chhan/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-1
coinNumLimit<-1
bandLimit<-0.3
changeThreshold<-0.05
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1.가장 시가총액이 높은 두 코인의 이동평균선 계산
#시가총액 비율:
indexCoin<-getIndexBalance(coinList[1:num,],1,"MARKET")
#이평선
type<-"days"
movingAvgDay<-30
unit<-60
count<-200
coinPriceHistory<-getCoinPriceHistory(indexCoin$market,type,unit,count)
coinPriceHistory<-coinPriceHistory[,.(market,candle_date_time_kst,trade_price)]
#현재가격 추가하기
curCoinPrices<-getCurrentUpbitPrice(indexCoin$market)
curCoinPrices[,candle_date_time_kst:=format(Sys.time(),'%Y-%m-%dT%H:%M:%S')]
coinPriceHistory<-rbind(coinPriceHistory,curCoinPrices)
setkeyv(coinPriceHistory,c("market","candle_date_time_kst"))
#이동평균선 구하기
movingAvg<-coinPriceHistory[,.(movingAvg=rollmean(trade_price,movingAvgDay)),by=market]
movingAvg<-movingAvg[,.(movingAvg=c(rep(NA,count+1-.N),movingAvg)),by=market]
coinPriceHistory<-cbind(coinPriceHistory,movingAvg=movingAvg$movingAvg)
coinPriceHistory[,disparity:=trade_price/movingAvg*100-100]
coinPriceHistory<-na.omit(coinPriceHistory)
getInvestRatio<-function(table){
for(i in 1:nrow(table)){
disparity<-table[i,]$disparity
if(disparity>0) {
addRatio<-floor(disparity)*0.5
}  else addRatio<-floor(disparity)*0.25
if(i>1){
prevRatio<-table[i-1,]$ratio
if(addRatio>=0) addRatio<-max(prevRatio,addRatio)
if(addRatio<0) addRatio<-min(1+addRatio,prevRatio)
}
newRatio<-min(1,addRatio)
newRatio<-max(0,newRatio)
table$ratio[i]<-newRatio
}
return(table)
}
coinPriceHistory<-coinPriceHistory[,getInvestRatio(.SD),by=market]
currentRatio<-coinPriceHistory[,tail(.SD,1),by=market][,.(market,ratio)]
failOrder<-c()
balanceCombinedTable<-merge(currentRatio,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(investRatio)]$investRatio<-0
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("/Users/chhan/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-1
coinNumLimit<-1
bandLimit<-0.3
changeThreshold<-0.05
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1.가장 시가총액이 높은 두 코인의 이동평균선 계산
#시가총액 비율:
indexCoin<-getIndexBalance(coinList[1:num,],1,"MARKET")
#이평선
type<-"days"
movingAvgDay<-30
unit<-60
count<-200
coinPriceHistory<-getCoinPriceHistory(indexCoin$market,type,unit,count)
coinPriceHistory<-coinPriceHistory[,.(market,candle_date_time_kst,trade_price)]
#현재가격 추가하기
curCoinPrices<-getCurrentUpbitPrice(indexCoin$market)
curCoinPrices[,candle_date_time_kst:=format(Sys.time(),'%Y-%m-%dT%H:%M:%S')]
coinPriceHistory<-rbind(coinPriceHistory,curCoinPrices)
setkeyv(coinPriceHistory,c("market","candle_date_time_kst"))
#이동평균선 구하기
movingAvg<-coinPriceHistory[,.(movingAvg=rollmean(trade_price,movingAvgDay)),by=market]
movingAvg<-movingAvg[,.(movingAvg=c(rep(NA,count+1-.N),movingAvg)),by=market]
coinPriceHistory<-cbind(coinPriceHistory,movingAvg=movingAvg$movingAvg)
coinPriceHistory[,disparity:=trade_price/movingAvg*100-100]
coinPriceHistory<-na.omit(coinPriceHistory)
getInvestRatio<-function(table){
for(i in 1:nrow(table)){
disparity<-table[i,]$disparity
if(disparity>0) {
addRatio<-floor(disparity)*0.5
}  else addRatio<-floor(disparity)*0.25
if(i>1){
prevRatio<-table[i-1,]$ratio
if(addRatio>=0) addRatio<-max(prevRatio,addRatio)
if(addRatio<0) addRatio<-min(1+addRatio,prevRatio)
}
newRatio<-min(1,addRatio)
newRatio<-max(0,newRatio)
table$ratio[i]<-newRatio
}
return(table)
}
coinPriceHistory<-coinPriceHistory[,getInvestRatio(.SD),by=market]
currentRatio<-coinPriceHistory[,tail(.SD,1),by=market][,.(market,ratio)]
failOrder<-c()
balanceCombinedTable<-merge(currentRatio,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*investRatio]
#setwd("/home/pi/stockInfoCrawler/StockTradebot/Rscript")
setwd("/Users/chhan/StockTradebot/Rscript")
source("./coinFunctionList.R",encoding="utf-8")
num<-1
coinNumLimit<-1
bandLimit<-0.3
changeThreshold<-0.05
currentBalance<-getCurrentBalance()
totalBalance<-currentBalance[,sum(balance)]
coinList<-getUpbitCoinListDetail(coinNumLimit)
#1.가장 시가총액이 높은 두 코인의 이동평균선 계산
#시가총액 비율:
indexCoin<-getIndexBalance(coinList[1:num,],1,"MARKET")
#이평선
type<-"days"
movingAvgDay<-30
unit<-60
count<-200
coinPriceHistory<-getCoinPriceHistory(indexCoin$market,type,unit,count)
coinPriceHistory<-coinPriceHistory[,.(market,candle_date_time_kst,trade_price)]
#현재가격 추가하기
curCoinPrices<-getCurrentUpbitPrice(indexCoin$market)
curCoinPrices[,candle_date_time_kst:=format(Sys.time(),'%Y-%m-%dT%H:%M:%S')]
coinPriceHistory<-rbind(coinPriceHistory,curCoinPrices)
setkeyv(coinPriceHistory,c("market","candle_date_time_kst"))
#이동평균선 구하기
movingAvg<-coinPriceHistory[,.(movingAvg=rollmean(trade_price,movingAvgDay)),by=market]
movingAvg<-movingAvg[,.(movingAvg=c(rep(NA,count+1-.N),movingAvg)),by=market]
coinPriceHistory<-cbind(coinPriceHistory,movingAvg=movingAvg$movingAvg)
coinPriceHistory[,disparity:=trade_price/movingAvg*100-100]
coinPriceHistory<-na.omit(coinPriceHistory)
getInvestRatio<-function(table){
for(i in 1:nrow(table)){
disparity<-table[i,]$disparity
if(disparity>0) {
addRatio<-floor(disparity)*0.5
}  else addRatio<-floor(disparity)*0.25
if(i>1){
prevRatio<-table[i-1,]$ratio
if(addRatio>=0) addRatio<-max(prevRatio,addRatio)
if(addRatio<0) addRatio<-min(1+addRatio,prevRatio)
}
newRatio<-min(1,addRatio)
newRatio<-max(0,newRatio)
table$ratio[i]<-newRatio
}
return(table)
}
coinPriceHistory<-coinPriceHistory[,getInvestRatio(.SD),by=market]
currentRatio<-coinPriceHistory[,tail(.SD,1),by=market][,.(market,ratio)]
failOrder<-c()
balanceCombinedTable<-merge(currentRatio,currentBalance,by="market",all=TRUE)
balanceCombinedTable[,totalBalance:=totalBalance]
balanceCombinedTable<-balanceCombinedTable[market!="KRW-KRW"]
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,symbol:=sapply(strsplit(market,"-"),function(x)x[2])]
balanceCombinedTable[,targetBalance:=totalBalance*ratio]
orderTable<-createOrderTable(balanceCombinedTable)
orderTable
if(sum(balanceCombinedTable$outsideofBand)){
orderTable<-createOrderTable(balanceCombinedTable)
failOrder<-orderCoin(orderTable[side=="ask"])
failOrder<-c(failOrder,orderCoin(orderTable[side=="bid"]))
} else{
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
log_print("Every coins are in the band. Buy Nothing")
log_close()
}
for(i in 1:5){
if(length(failOrder)==0){
if(sum(balanceCombinedTable$outsideofBand)){
orderTable<-createOrderTable(balanceCombinedTable)
failOrder<-orderCoin(orderTable[side=="ask"])
failOrder<-c(failOrder,orderCoin(orderTable[side=="bid"]))
} else{
logPath<-paste0(logDir,"coinLog.",Sys.Date(),".log")
log_open(logPath)
log_print("Every coins are in the band. Buy Nothing")
log_close()
}
} else{
orderTable<-orderTable[market %in% failOrder]
failOrder<-orderCoin(orderTable)
}
if(length(failOrder)==0) break;
Sys.sleep(60*10)
}
minimumOrder<-getMinimumOrderUnit(balanceCombinedTable$market)
balanceCombinedTable<-merge(balanceCombinedTable,minimumOrder,by.x="market",by.y="market",all=TRUE)
balanceCombinedTable[is.na(balance)]$balance<-0
balanceCombinedTable[is.na(targetBalance)]$targetBalance<-0
balanceCombinedTable[is.na(ratio)]$ratio<-0
balanceCombinedTable[is.na(curvolume)]$curvolume<-0
balanceCombinedTable[,diff:=targetBalance-balance]
balanceCombinedTable
