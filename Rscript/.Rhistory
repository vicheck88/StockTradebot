<<<<<<< HEAD
down_sector = POST(down_url, query = list(code = otp)) %>%
read_html(.,encoding='cp949') %>%
html_text() %>%
read_csv()
}
KRXIndividualStat<-function(businessDay){
# 개별종목 지표 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
gen_otp_data = list(
searchType = '1',
mktId = 'ALL',
csvxls_isNo = "false",
name = 'fileDown',
url = 'dbms/MDC/STAT/standard/MDCSTAT03501',
trdDd = businessDay # 최근영업일로 변경
)
otp = POST(gen_otp_url, query = gen_otp_data) %>%
read_html() %>%
html_text()
# 개별종목 지표 데이터 다운로드
down_url = 'http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd'
down_ind = POST(down_url, query = list(code = otp)) %>%
read_html(.,encoding='cp949') %>%
html_text() %>%
read_csv()
}
KRXMonitoringStat<-function(){
# 개별종목 지표 OTP 발급
gen_otp_url =
'http://data.krx.co.kr/comm/fileDn/GenerateOTP/generate.cmd'
gen_otp_data = list(
mktId = 'ALL',
csvxls_isNo = "false",
name = 'fileDown',
url = 'dbms/MDC/STAT/standard/MDCSTAT02001'
)
otp = POST(gen_otp_url, query = gen_otp_data) %>%
read_html() %>%
html_text()
# 개별종목 지표 데이터 다운로드
down_url = 'http://data.krx.co.kr/comm/fileDn/download_csv/download.cmd'
down_ind = POST(down_url, query = list(code = otp)) %>%
read_html(.,encoding='cp949') %>%
html_text() %>%
read_csv()
}
KRXDataMerge<-function(businessDay){
down_sector_KOSPI<-KRXIndStat(businessDay,'STK')
down_sector_KOSDAQ<-KRXIndStat(businessDay,'KSQ')
down_sector<-rbind(down_sector_KOSPI,down_sector_KOSDAQ)
down_monitoring<-KRXMonitoringStat()
down_monitoring$관리종목<-str_replace_all(down_monitoring$관리종목,'O','관리종목')
down_monitoring$관리종목<-str_replace_all(down_monitoring$관리종목,'X','-')
down_monitoring<-down_monitoring[,c(1,2,5)]
down_ind<-KRXIndividualStat(businessDay)
#데이터 정리(개별종목, 산업현황 데이터 병합)
setdiff(down_sector[,'종목명'],down_ind[,'종목명']) #겹치지 않은 종목 ->제외(일반적이지 않은 종목들)
KOR_ticker = merge(down_sector, down_ind,
by = intersect(names(down_sector),names(down_ind)),
all = FALSE
)
KOR_ticker<-merge(KOR_ticker,down_monitoring,by=c("종목코드","종목명"),all=FALSE)
setDT(KOR_ticker)
setorder(KOR_ticker,'시가총액') #시가총액으로 정렬
KOR_ticker <- KOR_ticker[!grepl('스팩', KOR_ticker$'종목명'),]
KOR_ticker <- KOR_ticker[str_sub(KOR_ticker$'종목코드', -1, -1) == 0,] #우선주
KOR_ticker$일자<-as.Date(businessDay,format='%Y%m%d')
KOR_ticker<-subset(KOR_ticker,select = c('일자','종목코드','종목명','시장구분','업종명','종가','시가총액',
'주당배당금','배당수익률','관리종목'))
names(KOR_ticker)<-c('일자','종목코드','종목명','시장구분','산업분류','현재가(종가)','시가총액',
'주당배당금','배당수익률','관리여부')
return(KOR_ticker)
}
WICSSectorInfo<-function(businessDay){
#각 섹터별로 정보 얻기
# 10: 에너지, 15: 소재, 20: 산업재, 25: 경기관련소비재, 30: 필수소비재, 35: 건강관리
# 40: 금융, 45: IT, 50: 커뮤니케이션서비스, 55: 유틸리티
sector_code = c('G25', 'G35', 'G50', 'G40', 'G10',
'G20', 'G55', 'G30', 'G15', 'G45')
data_sector = list()
for (i in sector_code) {
url = paste0(
'http://www.wiseindex.com/Index/GetIndexComponets',
'?ceil_yn=0&dt=',businessDay,'&sec_cd=',i)
data = fromJSON(url)
data = data$list
data_sector[[i]] = data
Sys.sleep(1)
}
data_sector = do.call(rbind, data_sector)
}
#KRX 데이터와 WICS데이터 조인 -> 특정 날에 존재한 기업에 대한 정보 획득
mergeWICSKRX<-function(businessDay){
KRX<-KRXDataMerge(businessDay)
WICS<-WICSSectorInfo(businessDay)[,c(1,2,4)]
table<-merge(WICS,KRX,by.x="CMP_CD",by.y="종목코드")
setnames(table,old=c("CMP_CD","IDX_CD","IDX_NM_KOR"),new=c("종목코드","섹션IDX","섹션"))
return(table)
}
adjustedPriceFromNaver<-function(interval, cnt, code){
# 오류 발생 시 이를 무시하고 다음 루프로 진행
tryCatch({
# url 생성
url = paste0(
'https://fchart.stock.naver.com/sise.nhn?symbol='
,code,'&timeframe=',interval,'&count=',cnt,'&requestType=0')
# 이 후 과정은 위와 동일함
# 데이터 다운로드
data = GET(url)
data_html = read_html(data, encoding = 'EUC-KR') %>%
html_nodes("item") %>%
html_attr("data")
# 데이터 나누기
price = read_delim(data_html, delim = '|')
# 필요한 열만 선택 후 클렌징
price = price[c(1, 5)]
price = data.frame(price)
colnames(price) = c('Date', code)
price[, 1] = ymd(price[, 1])
rownames(price) = price[, 1]
price[, 1] = NULL
return(price)
}, error = function(e) {
# 오류 발생시 해당 종목명을 출력
warning(paste0("Error in Ticker: ", code))
})
}
#각 월별 마지막 거래일 출력
getLastBizdayofMonth<-function(cnt){
return(rownames(adjustedPriceFromNaver('month',cnt,'005930')))
}
#Fnguide에서 데이터 받기
getFSHtmlFromFnGuide<-function(codeList){
htmlData<-list()
i<-1
for(code in codeList){
url = paste0(
'https://comp.fnguide.com/SVO2/ASP/'
,'SVD_Finance.asp?pGB=1&gicode=A',
code)
# 이 후 과정은 위와 동일함
# 데이터 다운로드 후 테이블 추출
data = GET(url) %>%
read_html() %>%
html_table()
htmlData[[code]]<-data
print(paste0(Sys.time()," : [",i,"/",length(codeList),"] Success: ",code))
i<-i+1
}
return(htmlData)
}
#Fnguide에서 받은 데이터 정리하기
cleanFSHtmlToDataFrame<-function(type,htmlData){
if(length(htmlData)==0) return(NULL)
data<-htmlData[[1]]
if(type=="Y") r=1 else r=2
idxList<-0:2*2+r
# 3개 재무제표를 하나로 합치기
data_IS<-data[[idxList[1]]]
data_BS<-data[[idxList[2]]]
data_CF<-data[[idxList[3]]]
data_IS<-data_IS[, 1:(ncol(data_IS)-2)]
data_IS$name<-'포괄손익계산서'
data_BS$name<-'재무상태표'
data_CF$name<-'현금흐름표'
data_fs<-rbind(data_IS,data_BS,data_CF)
# 데이터 클랜징
data_fs[, 1] = gsub('계산에 참여한 계정 펼치기','',data_fs[, 1])
data_fs = data_fs[!duplicated(data_fs[, 1]), ]
rownames(data_fs) = NULL
ftype<-data_fs[,1]
data_fs<-data_fs[,-1]
Name<-data_fs[,length(names(data_fs))]
data_fs<-data_fs[,-length(names(data_fs))]
data_fs = sapply(data_fs, function(x) {
str_replace_all(x, ',', '') %>%
as.numeric()
}) %>%
data.frame(., row.names = rownames(data_fs))
data_fs$'계정'<-ftype
data_fs$code<-names(htmlData)
data_fs$'항목'<-Name
data_fs<-subset(data_fs,select=c(6,7,5,1,2,3,4))
date<-names(data_fs)[4:7]
date<-str_replace_all(date,'[X]','')
names(data_fs)[4:7]<-date
if(type=='Q') {names(data_fs)[4:7]<-date} else{
month<-substr(date,6,7)
if(month[length(date)]!=month[1]) data_fs<-data_fs[,-length(names(data_fs))]
}
data_fs<-as.data.table(data_fs)
data_fs<-melt.data.table(data_fs,1:3)
names(data_fs)<-c("종목코드","종류","계정","일자","값")
data_fs$값<-data_fs$값*100000000
data_fs<-data_fs[!is.na(data_fs$값),]
return(data_fs)
}
getCurrentPrice<-function(code){
url = paste0('https://comp.fnguide.com/SVO2/ASP/SVD_main.asp?pGB=1&gicode=A',code)
data = GET(url)
price = read_html(data) %>%
html_node(xpath = '//*[@id="svdMainChartTxt11"]') %>%
html_text() %>%
parse_number()
return(price)
}
#현재 주식 수
getCurrentStockNumbers<-function(code){
url = paste0('https://comp.fnguide.com/SVO2/ASP/SVD_main.asp?pGB=1&gicode=A',code)
data = GET(url)
share = read_html(data) %>%
html_node(xpath = '//*[@id="svdMainGrid1"]/table/tbody/tr[7]/td[1]') %>%
html_text() %>%
strsplit('/') %>%
unlist() %>%
parse_number()
return(share)
}
#현재 보통주 수
getCurrentOrdinaryStockNumbers<-function(code){
return(getCurrentStockNumbers(code)[1])
}
#현재 우선주 수
getCurrentPreferredStockNumbers<-function(code){
return(getCurrentStockNumbers(code)[2])
}
getPriceList<-function(businessDay, codeList){
result<-c()
for(code in codeList){
result[code]=getCurrentPrice(code)
}
return(result)
}
getStockNumberList<-function(businessDay, codeList){
result<-data.frame(ordinary=double(),preferred=double())
for(code in codeList){
result[code,] <- getCurrentStockNumbers(code)
}
return(result)
}
cleanDataAndExtractEntitiesFromFS<-function(corpData,yearData,quarterData,isNew){
result<-NULL
tryCatch(
{
businessDate<-as.Date(corpData[[1]],format='%Y-%m-%d')
code<-corpData[[2]]
yData<-yearData[종목코드==code]
qData<-quarterData[종목코드==code]
lastYearDate<-businessDate %m+% months(-12)
yData<-yData[등록일자>=lastYearDate]
qData<-qData[등록일자>=lastYearDate]
if(!isNew){
yData<-yData[등록일자<=businessDate]
qData<-qData[등록일자<=businessDate]
}
yDate<-as.character(yData$일자)
qDate<-as.character(qData$일자)
qRank<-frank(-as.double(qDate),ties.method="dense")
yRank<-frank(-as.double(yDate),ties.method="dense")
if(length(yRank) == 0 & length(unique(qRank)) < 4 ){return(result)}
curQRange<-diff(range(as.double(qDate)[qRank<5]))
if(length(unique(qDate))>=4 & curQRange<=1){
data<-qData[qRank<=4]
} else{ data<-yData[yRank==1] }
result <- extractFSEntities(corpData, data)
},
error=function(e) print(paste0("Fail to Read: ",code," Date:",businessDate))
)
return(result)
}
sumQuarterData<-function(data){
fs<-data[data$종류=='재무상태표']
data<-data[data$종류!='재무상태표']
fs<-fs[fs$일자==max(fs$일자)]
fs<-fs[,-c('일자','등록일자')]
if(length(unique(data$일자))>1) data<-data[,.(값=sum(값)),by=c('종목코드','종류','계정')] else{
data<-data[,-c('일자','등록일자')]
}
names(fs)<-names(data)
data<-rbind(data,fs)
return(data)
}
extractFSEntities<-function(corpData,data){
marketPrice<-corpData$시가총액
code<-corpData$종목코드
data<-data[data$종목코드==code]
data<-unique(data,by=c("종목코드","종류","계정","일자"),fromLast=T)
if(length(unique(data$일자))==4){
data<-sumQuarterData(data)
}
#  data[,일자:=corpData[[1]]]
#  data<-subset(data,select=c(5,1,2,3,4))
value_type <- c('지배주주순이익','자본','자본금','영업활동으로인한현금흐름',
'재무활동으로인한현금흐름','투자활동으로인한현금흐름','매출액','매출총이익','영업이익',
'유동자산','부채','유상증자','자산','유동부채','당기순이익')
tmp<-data[data[,계정 %in% value_type]]$값
names(tmp)<-data[data[,계정 %in% value_type]]$계정
corpData[,':='(자산=tmp['자산'],유동자산=tmp['유동자산'],부채=tmp['부채'],유동부채=tmp['유동부채'],
자본=tmp['자본'],자본금=tmp['자본금'],매출액=tmp['매출액'],매출총이익=tmp['매출총이익'],
영업이익=tmp['영업이익'],지배주주순이익=tmp['지배주주순이익'],당기순이익=tmp['당기순이익'],
영업활동으로인한현금흐름=tmp['영업활동으로인한현금흐름'],
재무활동으로인한현금흐름=tmp['재무활동으로인한현금흐름'],
투자활동으로인한현금흐름=tmp['투자활동으로인한현금흐름'],
유상증자=tmp['유상증자'])]
return(corpData)
}
addMomentum<-function(businessDay, codeList){
result<-NULL
for(code in codeList){
tryCatch(
{
priceList<-adjustedPriceFromNaver('day',365,code)
Return<-Return.calculate(priceList)
Return<-Return[!is.na(Return)]
volatility<-sd(Return)*sqrt(length(Return))
monthPrice<-adjustedPriceFromNaver('month',14,code)[,1]
latestValue<-monthPrice[13]
monthlyMomentum<-latestValue/monthPrice[-12:-13]-1
avgMomentum<-(mean(monthlyMomentum))/volatility
result2<-rbind(result,unlist(c('종목코드'=code,Momentum=avgMomentum)))
Sys.sleep(0.3)
},
error=function(e) print(paste0("Fail to Read: ",code))
)
}
return(result)
}
winsorizing<-function(val){
newval<-ifelse(percent_rank(val)>0.99,
quantile(val,0.99,na.rm=TRUE),val)
return(newval)
}
day<-Sys.Date()
day<-str_remove_all(day,"-")
day
#전달 말 등록된 기업정보
df<-KRXDataMerge(day)
df
df[종목코드=='102110']
df['종목코드'=='102110']
df['종목코드'==102110]
df[,종목코드=='102110']
df[종목코드=="102110"]
ㅇㄹ
df
setDT(df)
df$일자
df$종목코드
df[종목코드==''045390]
df[종목코드=='045390']
print(paste0(Sys.time()," : Starting Script"))
library(RPostgres)
library(DBI)
library(jsonlite)
dbConfig=read_json("./config.json")$database
conn<-dbConnect(RPostgres::Postgres(),dbname=dbConfig$database,host=dbConfig$host,port=dbConfig$port,user=dbConfig$user,password=dbConfig$passwd)
#함수 불러돌이기
source("./RQuantFunctionList.R",encoding="utf-8")
#전월 말 날짜 구하기
print(paste0(Sys.time()," : Starting to get date"))
availableDate<-getLastBizdayofMonth(3)
if(month(Sys.Date())==month(availableDate[2])) {
availableDate<-availableDate[1]
} else{
availableDate<-availableDate[2]
}
latestDate<-dbGetQuery(conn,SQL("select max(일자) from metainfo.월별기업정보"))[,1]
while(TRUE){
tryCatch({
print(paste0(Sys.time()," : Starting to get current coporation list"))
day<-str_remove_all(availableDate,"-")
#전달 말 등록된 기업정보
df<-KRXDataMerge(day)
corpTable<-as.data.table(df)
break
}, error = function(e) {
print(paste0(Sys.time()," : Fail to get corp Data. Try again after 20mins"))
Sys.sleep(60*20)
})
}
#지금까지 등록되어있는 기업정보 구하기
corpList<-dbGetQuery(conn,SQL("select distinct 종목코드 from metainfo.월별기업정보"))$종목코드
corpList<-unique(c(corpList,corpTable$종목코드))
print(paste0(Sys.time()," : Starting to get FS"))
#최신 재무제표 받기
htmlData<-getFSHtmlFromFnGuide(corpList)
fsQ<-rbindlist(lapply(corpList,function(x){
cleanFSHtmlToDataFrame('Q',htmlData[x])
}))
fsY<-rbindlist(lapply(corpList,function(x){
cleanFSHtmlToDataFrame('Y',htmlData[x])
}))
/dbWriteTable
?dbWriteTable
?unname
a<-mtcars
a
unname(a)
?dbBind
con <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(con, "iris", iris)
install.packages("DBI")
library("DBI")
con <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(con, "iris", iris)
con
iris_result <- dbSendQuery(con, "SELECT * FROM iris WHERE [Petal.Width] > ?")
list(2.3)
iris_result
dbBind(iris_result, list(2.3))
dbFetch(iris_result)
con <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(con, "iris", iris)
# Using the same query for different values
iris_result <- dbSendQuery(con, "SELECT * FROM iris WHERE [Petal.Width] > ?")
dbFetch(iris_result)
library(quantmod)
library(PerformanceAnalytics)
library(magrittr)
library(tidyr)
library(dplyr)
library(corrplot)
library(nloptr)
getSymbols(symbols, src = 'yahoo')
rets = Return.calculate(prices) %>% na.omit()
covmat = cov(rets)
library(cccp)
w = getx(opt) %>% drop()
print(w)
symbols = c('XLP',
'XLY',
'JETS',
'PAVE',
'PBW',
'NRGU'
)
prices = do.call(cbind,
lapply(symbols, function(x) Ad(get(x)))) %>%
setNames(symbols)
cor(rets) %>%
corrplot(method = 'color', type = 'upper',
addCoef.col = 'black', number.cex = 0.7,
tl.cex = 0.6, tl.srt=45, tl.col = 'black',
col =
colorRampPalette(c('blue', 'white', 'red'))(200),
mar = c(0,0,0.5,0))
opt = rp(x0 = rep(1/length(symbols),length(symbols)),
P = covmat,
mrc = rep(1/length(symbols),length(symbols)))
w = (w / sum(w)) %>%
round(., 4) %>%
setNames(colnames(rets))
getSymbols(symbols, src = 'yahoo')
prices = do.call(cbind,
lapply(symbols, function(x) Ad(get(x)))) %>%
setNames(symbols)
rets = Return.calculate(prices) %>% na.omit()
cor(rets) %>%
corrplot(method = 'color', type = 'upper',
addCoef.col = 'black', number.cex = 0.7,
tl.cex = 0.6, tl.srt=45, tl.col = 'black',
col =
colorRampPalette(c('blue', 'white', 'red'))(200),
mar = c(0,0,0.5,0))
covmat = cov(rets)
library(cccp)
opt = rp(x0 = rep(1/length(symbols),length(symbols)),
P = covmat,
mrc = rep(1/length(symbols),length(symbols)))
w = getx(opt) %>% drop()
w = (w / sum(w)) %>%
round(., 4) %>%
setNames(colnames(rets))
print(w)
w*4000
library(quantmod)
library(PerformanceAnalytics)
library(magrittr)
library(tidyr)
library(dplyr)
library(corrplot)
library(nloptr)
symbols = c('XLP',
'XLY',
'JETS',
'PAVE',
'NRGU'
)
getSymbols(symbols, src = 'yahoo')
prices = do.call(cbind,
lapply(symbols, function(x) Ad(get(x)))) %>%
setNames(symbols)
rets = Return.calculate(prices) %>% na.omit()
cor(rets) %>%
corrplot(method = 'color', type = 'upper',
addCoef.col = 'black', number.cex = 0.7,
tl.cex = 0.6, tl.srt=45, tl.col = 'black',
col =
colorRampPalette(c('blue', 'white', 'red'))(200),
mar = c(0,0,0.5,0))
covmat = cov(rets)
library(cccp)
opt = rp(x0 = rep(1/length(symbols),length(symbols)),
P = covmat,
mrc = rep(1/length(symbols),length(symbols)))
w = getx(opt) %>% drop()
w = (w / sum(w)) %>%
round(., 4) %>%
setNames(colnames(rets))
print(w)
w*4000
=======
table<-getEqualWeightBalanceDiff(10)
table<-table[buyamount!=0]
table[,market:=paste("KRW",market,sep="-")]
table$ord_type<-'limit'
table$side<-'bid'
table[buyamount<0]$side<-'ask'
table[,buyamount:=abs(buyamount)]
table[,price:=getCurrentUpbitPrice(table$market)$trade_price]
table[,volume:=buyamount/price]
table<-subset(table,select=c("market","side","volume","price","ord_type"))
table
order<-table[1,]
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
query
token<-createJwtToken(query)
url<-"https://api.upbit.com/v1/orders"
as.list(order)
r<-POST(url,add_headers(Authorization=paste0("Bearer ",token)),body=as.list(order),encode='json')
r$status_code
rawToChar(r$content)
order<-table
order
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
token<-createJwtToken(query)
query
token
sapply(query,function(x) createJwtToken(x))
a<-sapply(query,function(x) createJwtToken(x))
a[1]
a[[1]]
sapply(a,print)
sapply(a,print(a[[1]]))
sapply(a,paste0("Bearer ",a)))
sapply(a,paste0("Bearer ",.))
sapply(a,function(x) paste0("Bearer ",x))
source('~/Github/StockTradebot/Rscript/coinFunctionList.R')
setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
pkg = c('quantmod','jsonlite', 'stringr',
'jose','openssl','PerformanceAnalytics','xts','curl','data.table',
'httr')
new.pkg = pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg)) {
install.packages(new.pkg, dependencies = TRUE)}
sapply(pkg,library,character.only=T)
getCoinMarketCapList<-function(){
coinMarket_api_key<-"7a53f6d1-41fd-4658-836a-b59e6432f5cf"
h<-new_handle()
handle_setheaders(h, .list=list("X-CMC_PRO_API_KEY"=coinMarket_api_key, Accepts="application/json"))
url<-"https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest"
r <- curl_fetch_memory(url, h)
result<-fromJSON(rawToChar(r$content))$data
priceList<-result$quote$USD
coinMarketTable<-data.table(name=result$name,symbol=result$symbol,priceList)
return(coinMarketTable[order(-market_cap)])
}
getUpbitCoinList<-function(){
url<-'https://api.upbit.com/v1/market/all?isDetails=false'
h<-new_handle()
handle_setheaders(h, .list=list(Accepts="application/json"))
r <- curl_fetch_memory(url, h)
upbitCoinTable<-rawToChar(r$content)
Encoding(upbitCoinTable)<-"UTF-8"
upbitCoinTable<-as.data.table(fromJSON(upbitCoinTable))
upbitCoinTable<-upbitCoinTable[substr(market,1,3)=="KRW"]
upbitCoinTable[,market:=str_replace(market,"KRW-","")]
return(upbitCoinTable)
}
getTopNUpbitCoinList<-function(num){
coinMarketCapTable<-getCoinMarketCapList()
upbitCoinTable<-getUpbitCoinList()
coinTable<-coinMarketCapTable[upbitCoinTable,on=c(symbol="market"),nomatch=0]
coinTable<-coinTable[order(-market_cap)]
coinTable<-subset(coinTable,select=-english_name)
return(coinTable[1:num,])
}
createJwtToken<-function(query){
upbitConfig<-fromJSON("./config.json")$upbit_key
uuid<-as.character(as.numeric(Sys.time()))
query_hash_alg<-"SHA512"
if(is.null(query)){
jwtClaim<-jwt_claim(access_key=upbitConfig$access_key,nonce=uuid)
jwtToken<-jwt_encode_hmac(jwtClaim,upbitConfig$secret_key,256)
} else{
q<-as.character(sha512(query))
jwtClaim<-jwt_claim(iat=NULL,
access_key=upbitConfig$access_key,
nonce=uuid,
query_hash=q,
query_hash_alg=query_hash_alg)
jwtToken<-jwt_encode_hmac(jwtClaim,upbitConfig$secret_key,256)
}
return(jwtToken)
}
getResponseParam<-function(url, query){
jwtToken<-createJwtToken(query)
h<-new_handle()
handle_setheaders(h, .list=list(Accept="application/json",
Authorization=paste0("Bearer ",jwtToken)))
return(fromJSON(rawToChar(curl_fetch_memory(url, h)$content)))
}
getCurrentUpbitAccountInfo<-function(){
url<-"https://api.upbit.com/v1/accounts"
result<-getResponseParam(url,NULL)
result$balance<-as.numeric(result$balance)
result$avg_buy_price<-as.numeric(result$avg_buy_price)
setDT(result)
return(result)
}
getCurrentUpbitPrice<-function(coinList){
krwCoinString=paste(coinList,collapse=',')
url <- paste0('https://api.upbit.com/v1/ticker?markets=',krwCoinString,'&count=',1)
h<-new_handle()
handle_setheaders(h, .list=list(Accepts="application/json"))
priceList<-as.data.table(fromJSON(rawToChar(curl_fetch_memory(url, h)$content)))
priceList<-priceList[,.(market,trade_price)]
return(priceList)
}
getCoinPriceHistory<-function(coinList,type,unit,count){
#coinList<-paste("KRW",coinList,sep="-")
if(type=="minutes") {
candle<-paste0("minutes/",unit)
} else {candle<-type}
url <- paste0('https://api.upbit.com/v1/candles/'
,candle,'?market=',coinList,'&count=',count)
h<-new_handle()
handle_setheaders(h, .list=list(Accepts="application/json"))
res<-list()
for(u in url){
res[[u]] <- fromJSON(rawToChar(curl_fetch_memory(u, h)$content))
Sys.sleep(0.1)
}
return(rbindlist(res))
}
getMomentumHistory<-function(coinList,candleType,unit,count,priceType,momentumPeriod){
priceList<-getCoinPriceHistory(coinList,candleType,unit,count)
priceList<-subset(priceList,select=c("market","candle_date_time_kst",priceType))
priceList[,prevPrice:=shift(get(priceType),momentumPeriod,NA,"lead"),by=market]
priceList<-na.omit(priceList)
priceList[,momentum:=get(priceType)/prevPrice*100]
return(subset(priceList,select=c("market","candle_date_time_kst","momentum")))
}
getEqualWeightBalanceDiff<-function(num){
topNCoinList<-getTopNUpbitCoinList(num)
balanceList<-getCurrentUpbitAccountInfo()
totalBalance<-sum(balanceList$balance)
topNCoinList$targetbalance<-rep(totalBalance/num,num)
topNCoinList<-topNCoinList[,.(name,symbol,price,targetbalance)]
curBalanceList<-balanceList[,.(currency,balance)]
joinList<-merge(topNCoinList,curBalanceList,by.x="symbol",by.y="currency",all=TRUE)
joinList<-joinList[symbol!="KRW"]
joinList[is.na(balance)]$balance<-0
joinList[is.na(targetbalance)]$targetbalance<-0
joinList[,diff:=targetbalance-balance]
joinList<-joinList[,.(symbol,diff)]
names(joinList)<-c("market","buyamount")
return(joinList)
}
rebalanceWeight<-function(table){
table<-table[buyamount!=0]
table[,market:=paste("KRW",market,sep="-")]
table$ord_type<-'limit'
table$side<-'bid'
table[buyamount<0]$side<-'ask'
table[,buyamount:=abs(buyamount)]
table[,price:=getCurrentUpbitPrice(table$market)$trade_price]
table[,volume:=buyamount/price]
table<-subset(table,select=c("market","side","volume","price","ord_type"))
orderCoin(table)
}
getOrderList<-function(status){
query<-paste0("state=",status)
url<-"https://api.upbit.com/v1/orders"
}
orderCoin<-function(order){
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x))
url<-"https://api.upbit.com/v1/orders"
for(i in 1:NROW(order)){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",token)),body=as.list(order),encode='json')
r$status_code
rawToChar(r$content)
}
}
orderCoin(rebalanceWeight(getEqualWeightBalanceDiff(10)))
order<-rebalanceWeight(getEqualWeightBalanceDiff(10))
order
getEqualWeightBalanceDiff(10)
num<-10
topNCoinList<-getTopNUpbitCoinList(num)
balanceList<-getCurrentUpbitAccountInfo()
balanceList
balanceList[,total:=balance*(avg_buy_price==0?1:avg_buy_price)]
30.07519*3325
a<-1==0?1:0
balanceList[avg_buy_price==0]$avg_buy_price=1
balanceList
balanceList[avg_buy_price==0]$avg_buy_price<-1
balanceList
balanceList[sum(balance*avg_buy_price)]
balanceList[balance*avg_buy_price]
str(balanceList)
balanceList[test:=balance*avg_buy_price]
balanceList[,balance*avg_buy_price]
balanceList[,sum(balance*avg_buy_price)]
totalBalance<-balanceList[,sum(balance*avg_buy_price)]
topNCoinList$targetbalance<-rep(totalBalance/num,num)
topNCoinList
topNCoinList<-topNCoinList[,.(name,symbol,price,targetbalance)]
curBalanceList<-balanceList[,.(currency,balance)]
curBalanceList
curBalanceList<-balanceList[,.(currency,balance*avg_buy_price)]
curBalanceList
joinList<-merge(topNCoinList,curBalanceList,by.x="symbol",by.y="currency",all=TRUE)
joinList
joinList<-joinList[symbol!="KRW"]
joinList
joinList[is.na(balance)]$balance<-0
curBalanceList<-balanceList[,.(currency,balance=balance*avg_buy_price)]
curBalanceList
joinList<-merge(topNCoinList,curBalanceList,by.x="symbol",by.y="currency",all=TRUE)
joinList<-joinList[symbol!="KRW"]
joinList[is.na(balance)]$balance<-0
joinList
joinList[is.na(targetbalance)]$targetbalance<-0
joinList[,diff:=targetbalance-balance]
joinList
joinList<-joinList[,.(symbol,diff)]
names(joinList)<-c("market","buyamount")
setwd("C:/Users/vicen/Documents/Github/StockTradebot/Rscript")
pkg = c('quantmod','jsonlite', 'stringr',
'jose','openssl','PerformanceAnalytics','xts','curl','data.table',
'httr')
new.pkg = pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg)) {
install.packages(new.pkg, dependencies = TRUE)}
sapply(pkg,library,character.only=T)
getCoinMarketCapList<-function(){
coinMarket_api_key<-"7a53f6d1-41fd-4658-836a-b59e6432f5cf"
h<-new_handle()
handle_setheaders(h, .list=list("X-CMC_PRO_API_KEY"=coinMarket_api_key, Accepts="application/json"))
url<-"https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest"
r <- curl_fetch_memory(url, h)
result<-fromJSON(rawToChar(r$content))$data
priceList<-result$quote$USD
coinMarketTable<-data.table(name=result$name,symbol=result$symbol,priceList)
return(coinMarketTable[order(-market_cap)])
}
getUpbitCoinList<-function(){
url<-'https://api.upbit.com/v1/market/all?isDetails=false'
h<-new_handle()
handle_setheaders(h, .list=list(Accepts="application/json"))
r <- curl_fetch_memory(url, h)
upbitCoinTable<-rawToChar(r$content)
Encoding(upbitCoinTable)<-"UTF-8"
upbitCoinTable<-as.data.table(fromJSON(upbitCoinTable))
upbitCoinTable<-upbitCoinTable[substr(market,1,3)=="KRW"]
upbitCoinTable[,market:=str_replace(market,"KRW-","")]
return(upbitCoinTable)
}
getTopNUpbitCoinList<-function(num){
coinMarketCapTable<-getCoinMarketCapList()
upbitCoinTable<-getUpbitCoinList()
coinTable<-coinMarketCapTable[upbitCoinTable,on=c(symbol="market"),nomatch=0]
coinTable<-coinTable[order(-market_cap)]
coinTable<-subset(coinTable,select=-english_name)
return(coinTable[1:num,])
}
createJwtToken<-function(query){
upbitConfig<-fromJSON("./config.json")$upbit_key
uuid<-as.character(as.numeric(Sys.time()))
query_hash_alg<-"SHA512"
if(is.null(query)){
jwtClaim<-jwt_claim(access_key=upbitConfig$access_key,nonce=uuid)
jwtToken<-jwt_encode_hmac(jwtClaim,upbitConfig$secret_key,256)
} else{
q<-as.character(sha512(query))
jwtClaim<-jwt_claim(iat=NULL,
access_key=upbitConfig$access_key,
nonce=uuid,
query_hash=q,
query_hash_alg=query_hash_alg)
jwtToken<-jwt_encode_hmac(jwtClaim,upbitConfig$secret_key,256)
}
return(jwtToken)
}
getResponseParam<-function(url, query){
jwtToken<-createJwtToken(query)
h<-new_handle()
handle_setheaders(h, .list=list(Accept="application/json",
Authorization=paste0("Bearer ",jwtToken)))
return(fromJSON(rawToChar(curl_fetch_memory(url, h)$content)))
}
getCurrentUpbitAccountInfo<-function(){
url<-"https://api.upbit.com/v1/accounts"
result<-getResponseParam(url,NULL)
result$balance<-as.numeric(result$balance)
result$avg_buy_price<-as.numeric(result$avg_buy_price)
setDT(result)
return(result)
}
getCurrentUpbitPrice<-function(coinList){
krwCoinString=paste(coinList,collapse=',')
url <- paste0('https://api.upbit.com/v1/ticker?markets=',krwCoinString,'&count=',1)
h<-new_handle()
handle_setheaders(h, .list=list(Accepts="application/json"))
priceList<-as.data.table(fromJSON(rawToChar(curl_fetch_memory(url, h)$content)))
priceList<-priceList[,.(market,trade_price)]
return(priceList)
}
getCoinPriceHistory<-function(coinList,type,unit,count){
#coinList<-paste("KRW",coinList,sep="-")
if(type=="minutes") {
candle<-paste0("minutes/",unit)
} else {candle<-type}
url <- paste0('https://api.upbit.com/v1/candles/'
,candle,'?market=',coinList,'&count=',count)
h<-new_handle()
handle_setheaders(h, .list=list(Accepts="application/json"))
res<-list()
for(u in url){
res[[u]] <- fromJSON(rawToChar(curl_fetch_memory(u, h)$content))
Sys.sleep(0.1)
}
return(rbindlist(res))
}
getMomentumHistory<-function(coinList,candleType,unit,count,priceType,momentumPeriod){
priceList<-getCoinPriceHistory(coinList,candleType,unit,count)
priceList<-subset(priceList,select=c("market","candle_date_time_kst",priceType))
priceList[,prevPrice:=shift(get(priceType),momentumPeriod,NA,"lead"),by=market]
priceList<-na.omit(priceList)
priceList[,momentum:=get(priceType)/prevPrice*100]
return(subset(priceList,select=c("market","candle_date_time_kst","momentum")))
}
getEqualWeightBalanceDiff<-function(num){
topNCoinList<-getTopNUpbitCoinList(num)
balanceList<-getCurrentUpbitAccountInfo()
balanceList[avg_buy_price==0]$avg_buy_price<-1
totalBalance<-balanceList[,sum(balance*avg_buy_price)]
topNCoinList$targetbalance<-rep(totalBalance/num,num)
topNCoinList<-topNCoinList[,.(name,symbol,price,targetbalance)]
curBalanceList<-balanceList[,.(currency,balance=balance*avg_buy_price)]
joinList<-merge(topNCoinList,curBalanceList,by.x="symbol",by.y="currency",all=TRUE)
joinList<-joinList[symbol!="KRW"]
joinList[is.na(balance)]$balance<-0
joinList[is.na(targetbalance)]$targetbalance<-0
joinList[,diff:=targetbalance-balance]
joinList<-joinList[,.(symbol,diff)]
names(joinList)<-c("market","buyamount")
return(joinList)
}
rebalanceWeight<-function(table){
table<-table[buyamount!=0]
table[,market:=paste("KRW",market,sep="-")]
table$ord_type<-'limit'
table$side<-'bid'
table[buyamount<0]$side<-'ask'
table[,buyamount:=abs(buyamount)]
table[,price:=getCurrentUpbitPrice(table$market)$trade_price]
table[,volume:=buyamount/price]
table<-subset(table,select=c("market","side","volume","price","ord_type"))
orderCoin(table)
}
getOrderList<-function(status){
query<-paste0("state=",status)
url<-"https://api.upbit.com/v1/orders"
}
orderCoin<-function(order){
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x))
url<-"https://api.upbit.com/v1/orders"
for(i in 1:NROW(order)){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",token)),body=as.list(order),encode='json')
r$status_code
rawToChar(r$content)
}
}
table<-getEqualWeightBalanceDiff(10)
table
rebalanceWeight(table)
orderCoin<-function(order){
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x))
url<-"https://api.upbit.com/v1/orders"
for(i in 1:NROW(order)){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",token)),body=as.list(order),encode='json')
print(r$status_code)
rawToChar(r$content)
}
}
rebalanceWeight(table)
orderCoin<-function(order){
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x))
url<-"https://api.upbit.com/v1/orders"
for(i in 1:NROW(order)){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",token)),body=as.list(order),encode='json')
print(r$status_code)
rawToChar(r$content)
Sys.sleep(0.1)
}
}
rebalanceWeight(table)
table<-getEqualWeightBalanceDiff(10)
table<-table[buyamount!=0]
table[,market:=paste("KRW",market,sep="-")]
table$ord_type<-'limit'
table$side<-'bid'
table[buyamount<0]$side<-'ask'
table[,buyamount:=abs(buyamount)]
table[,price:=getCurrentUpbitPrice(table$market)$trade_price]
table[,volume:=buyamount/price]
table<-subset(table,select=c("market","side","volume","price","ord_type"))
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x))
url<-"https://api.upbit.com/v1/orders"
query
tokenList
order
order<-table
order
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x))
query
token
orderCoin<-function(order){
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x))
url<-"https://api.upbit.com/v1/orders"
for(i in 1:NROW(order)){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",tokenList[i])),body=as.list(order),encode='json')
print(r$status_code)
rawToChar(r$content)
Sys.sleep(0.1)
}
}
order
orderCoin(order)
NROW(order)
tokenList[1]
tokenList[2]
tokenList[3]
orderCoin<-function(order){
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x))
url<-"https://api.upbit.com/v1/orders"
for(i in 1:NROW(order)){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",tokenList[i])),body=as.list(order[i,]),encode='json')
print(r$status_code)
rawToChar(r$content)
Sys.sleep(0.1)
}
}
order
orderCoin(order)
orderCoin<-function(order){
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x))
url<-"https://api.upbit.com/v1/orders"
for(i in 1:NROW(order)){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",tokenList[i])),body=as.list(order[i,]),encode='json')
print(r$status_code)
print(rawToChar(r$content))
Sys.sleep(0.1)
}
}
orderCoin(rebalanceWeight(getEqualWeightBalanceDiff(10)))
source('~/Github/StockTradebot/Rscript/coinFunctionList.R')
getEqualWeightBalanceDiff(10)
table<-getEqualWeightBalanceDiff(10)
table
table<-table[buyamount!=0]
table[,market:=paste("KRW",market,sep="-")]
table$ord_type<-'limit'
table$side<-'bid'
table[buyamount<0]$side<-'ask'
table
table[,buyamount:=abs(buyamount)]
table[,price:=getCurrentUpbitPrice(table$market)$trade_price]
table[,volume:=buyamount/price]
table<-subset(table,select=c("market","side","volume","price","ord_type"))
table
orderCoin(table)
orderCoin<-function(order){
query<-paste0("market=",order$market,"&side=",order$side,"&volume=",order$volume,"&price=",order$price,"&ord_type=",order$ord_type)
tokenList<-sapply(query,function(x) createJwtToken(x))
url<-"https://api.upbit.com/v1/orders"
for(i in 1:NROW(order)){
res<-POST(url,add_headers(Authorization=paste0("Bearer ",tokenList[i])),body=as.list(order[i,]),encode='json')
print(res$status_code)
print(rawToChar(res$content))
Sys.sleep(0.3)
}
}
orderCoin(table)
jwtToken
strsplit(jwtToken,'.')
?strsplit
strsplit(jwtToken,'[.]')
strsplit(jwtToken,'[.]')[3]
strsplit(jwtToken,'[.]')[[1]][3]
sign<-strsplit(jwtToken,'[.]')[[1]][3]
sign
base64_decode(sign)
base64_dec(sign)
jwt_decode_hmac(sign)
jwt_split(jwt)(jwtCliam)
jwt_split(jwt)(jwtClaim)
jwt_split(jwtClaim)
jwtClaim
token
jwtToken
jwt_split(jwtToken)
>>>>>>> a85fba660e1b8342889953cb04505dd2d19ba7be
